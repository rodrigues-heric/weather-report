// node_modules/i18next/dist/esm/i18next.js
var isString = (obj) => typeof obj === "string";
var defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
var makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
var copy = (a, s, t2) => {
  a.forEach((m) => {
    if (s[m]) t2[m] = s[m];
  });
};
var lastOfPathSeparatorRegExp = /###/g;
var cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
var canNotTraverseDeeper = (object) => !object || isString(object);
var getLastOfPath = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
var setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
};
var pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
var getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  if (!Object.prototype.hasOwnProperty.call(obj, k)) return void 0;
  return obj[k];
};
var getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
var deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
var regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
var escape = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};
var RegExpCache = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
var looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
var deepFind = (obj, path, keySeparator = ".") => {
  if (!obj) return void 0;
  if (obj[path]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path)) return void 0;
    return obj[path];
  }
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
var getCleanedCode = (code) => code?.replace("_", "-");
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
var Logger = class _Logger {
  constructor(concreteLogger, options = {}) {
    this.init(concreteLogger, options);
  }
  init(concreteLogger, options = {}) {
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log(...args) {
    return this.forward(args, "log", "", true);
  }
  warn(...args) {
    return this.forward(args, "warn", "", true);
  }
  error(...args) {
    return this.forward(args, "error", "");
  }
  deprecate(...args) {
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event, ...args) {
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
var ResourceStore = class extends EventEmitter {
  constructor(data, options = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key, options = {}) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value, options = {
    silent: false
  }) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources, options = {
    silent: false
  }) {
    for (const m in resources) {
      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite, options = {
    silent: false,
    skipCopy: false
  }) {
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};
var PATH_KEY = Symbol("i18next/PATH_KEY");
function createProxy() {
  const state = [];
  const handler = /* @__PURE__ */ Object.create(null);
  let proxy;
  handler.get = (target, key) => {
    proxy?.revoke?.();
    if (key === PATH_KEY) return state;
    state.push(key);
    proxy = Proxy.revocable(target, handler);
    return proxy.proxy;
  };
  return Proxy.revocable(/* @__PURE__ */ Object.create(null), handler).proxy;
}
function keysFromSelector(selector, opts) {
  const {
    [PATH_KEY]: path
  } = selector(createProxy());
  return path.join(opts?.keySeparator ?? ".");
}
var checkedLoadedFor = {};
var shouldHandleAsObject = (res) => !isString(res) && typeof res !== "boolean" && typeof res !== "number";
var Translator = class _Translator extends EventEmitter {
  constructor(services, options = {}) {
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key, o = {
    interpolation: {}
  }) {
    const opt = {
      ...o
    };
    if (key == null) return false;
    const resolved = this.resolve(key, opt);
    if (resolved?.res === void 0) return false;
    const isObject = shouldHandleAsObject(resolved.res);
    if (opt.returnObjects === false && isObject) {
      return false;
    }
    return true;
  }
  extractFromKey(key, opt) {
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    let namespaces = opt.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, o, lastKey) {
    let opt = typeof o === "object" ? {
      ...o
    } : o;
    if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
      opt = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof opt === "object") opt = {
      ...opt
    };
    if (!opt) opt = {};
    if (keys == null) return "";
    if (typeof keys === "function") keys = keysFromSelector(keys, {
      ...this.options,
      ...opt
    });
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], opt);
    const namespace = namespaces[namespaces.length - 1];
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const lng = opt.lng || this.language;
    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(opt)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(opt)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, opt);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
    const hasDefaultValue = _Translator.hasDefaultValue(opt);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!opt.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...opt,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            if (hasDefaultValue && !res) {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : void 0,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m] === deepKey) copy2[m] = resForObjHndl[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, opt, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...opt,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
        } else {
          lngs.push(opt.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, opt);
              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, opt, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
        res = `${namespace}${nsSeparator}${key}`;
      }
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : void 0, opt);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(opt);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, opt, resolved, lastKey) {
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...opt
      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!opt.skipInterpolation) {
      if (opt.interpolation) this.interpolator.init({
        ...opt,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...opt.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) opt.nest = false;
      }
      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
      if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {
        if (lastKey?.[0] === args[0] && !opt.context) {
          this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return this.translate(...args, key);
      }, opt);
      if (opt.interpolation) this.interpolator.reset();
    }
    const postProcess = opt.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(opt)
        },
        ...opt
      } : opt, this);
    }
    return res;
  }
  resolve(keys, opt = {}) {
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, opt);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
      const needsContextHandling = opt.context !== void 0 && (isString(opt.context) || typeof opt.context === "number") && opt.context !== "";
      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              finalKeys.push(key + pluralSuffix);
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator || "_"}${opt.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                finalKeys.push(contextKey + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, opt);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key, options = {}) {
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails(options = {}) {
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e) {
      }
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngScOnly = this.getScriptPartFromCode(code);
        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
var dummyRule = {
  select: (count) => count === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
var PluralResolver = class {
  constructor(languageUtils, options = {}) {
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code, options = {}) {
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key, options = {}) {
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count, options = {}) {
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options);
  }
};
var deepFindWithDefaults = (data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
var regexSafe = (val) => val.replace(/\$/g, "$$$$");
var Interpolator = class {
  constructor(options = {}) {
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options?.interpolation?.format || ((value) => value);
    this.init(options);
  }
  init(options = {}) {
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc, options = {}) {
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf("}") + 1 : match[1].indexOf(this.formatSeparator);
      if (keyEndIndex !== -1) {
        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem) => elem.trim()).filter(Boolean);
        match[1] = match[1].slice(0, keyEndIndex);
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (formatters.length) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
var parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
var createCachedFormatter = (fn) => {
  const cache = {};
  return (v, l, o) => {
    let optForCache = o;
    if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [o.interpolationkey]: void 0
      };
    }
    const key = l + JSON.stringify(optForCache);
    let frm = cache[key];
    if (!frm) {
      frm = fn(getCleanedCode(l), o);
      cache[key] = frm;
    }
    return frm(v);
  };
};
var createNonCachedFormatter = (fn) => (v, l, o) => fn(getCleanedCode(l), o)(v);
var Formatter = class {
  constructor(options = {}) {
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.init(options);
  }
  init(services, options = {
    interpolation: {}
  }) {
    this.formatSeparator = options.interpolation.formatSeparator || ",";
    const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
    this.formats = {
      number: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: cf((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: cf((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: cf((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng, options = {}) {
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
var removePending = (q, name) => {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
};
var Connector = class extends EventEmitter {
  constructor(backend, store, services, options = {}) {
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces, options = {}, callback) {
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name, prefix = "") {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {
  }) {
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
var get = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  },
  cacheInBuiltFormats: true
});
var transformOptions = (options) => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  if (typeof options.initImmediate === "boolean") options.initAsync = options.initImmediate;
  return options;
};
var noop = () => {
};
var bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
var I18n = class _I18n extends EventEmitter {
  constructor(options = {}, callback) {
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init(options = {}, callback) {
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;
      if (usingLegacyFormatFunction) {
        this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);
      }
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        if (s.formatter.init) s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = (...args) => this.store[fcName](...args);
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = (...args) => {
        this.store[fcName](...args);
        return this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language, callback = noop) {
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      this.options.preload?.forEach?.((l) => append(l));
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
    if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {
      this.resolvedLanguage = l;
      this.languages.unshift(l);
    }
  }
  changeLanguage(lng, callback) {
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        if (this.isLanguageChangingTo === lng) {
          setLngProps(l);
          this.translator.changeLanguage(l);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l);
          this.logger.log("languageChanged", l);
        }
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve((...args) => this.t(...args));
      if (callback) callback(err, (...args) => this.t(...args));
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const fl = isString(lngs) ? lngs : lngs && lngs[0];
      const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [lngs] : lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        this.services.languageDetector?.cacheUserLanguage?.(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    const fixedT = (key, opts, ...rest) => {
      let o;
      if (typeof opts !== "object") {
        o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        o = {
          ...opts
        };
      }
      o.lng = o.lng || fixedT.lng;
      o.lngs = o.lngs || fixedT.lngs;
      o.ns = o.ns || fixedT.ns;
      if (o.keyPrefix !== "") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = this.options.keySeparator || ".";
      let resultKey;
      if (o.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => {
          if (typeof k === "function") k = keysFromSelector(k, {
            ...this.options,
            ...opts
          });
          return `${o.keyPrefix}${keySeparator}${k}`;
        });
      } else {
        if (typeof key === "function") key = keysFromSelector(key, {
          ...this.options,
          ...opts
        });
        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
      }
      return this.t(resultKey, o);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t(...args) {
    return this.translator?.translate(...args);
  }
  exists(...args) {
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns, options = {}) {
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    try {
      const l = new Intl.Locale(lng);
      if (l && l.getTextInfo) {
        const ti = l.getTextInfo();
        if (ti && ti.direction) return ti.direction;
      }
    } catch (e) {
    }
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());
    if (lng.toLowerCase().indexOf("-latn") > 1) return "ltr";
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(options = {}, callback) {
    const instance2 = new _I18n(options, callback);
    instance2.createInstance = _I18n.createInstance;
    return instance2;
  }
  cloneInstance(options = {}, callback = noop) {
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new _I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
        prev[l] = {
          ...this.store.data[l]
        };
        prev[l] = Object.keys(prev[l]).reduce((acc, n) => {
          acc[n] = {
            ...prev[l][n]
          };
          return acc;
        }, prev[l]);
        return prev;
      }, {});
      clone.store = new ResourceStore(clonedData, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    if (options.interpolation) clone.services.interpolator = new Interpolator(mergedOptions);
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", (event, ...args) => {
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

export {
  keysFromSelector,
  instance,
  createInstance,
  dir,
  init,
  loadResources,
  reloadResources,
  use,
  changeLanguage,
  getFixedT,
  t,
  exists,
  setDefaultNamespace,
  hasLoadedNamespace,
  loadNamespaces,
  loadLanguages
};
//# sourceMappingURL=chunk-MOZ4RPRG.js.map
         x      20251217233610-8lc >B`J   http://localhost:5173/node_modules/.vite/deps/chunk-MOZ4RPRG.js?v=e7284969   c h u n k - M O Z 4 R P R G . j s . m a p       r9 // node_modules/i18next/dist/esm/i18next.js
var isString = (obj) => typeof obj === "string";
var defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
var makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
var copy = (a, s, t2) => {
  a.forEach((m) => {
    if (s[m]) t2[m] = s[m];
  });
};
var lastOfPathSeparatorRegExp = /###/g;
var cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
var canNotTraverseDeeper = (object) => !object || isString(object);
var getLastOfPath = (object, path, Empty) => {
  const stack = !isString(path) ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
var setPath = (object, path, newValue) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e = `${p[p.length - 1]}.${e}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last?.obj && typeof last.obj[`${last.k}.${e}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e}`] = newValue;
};
var pushPath = (object, path, newValue, concat) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  obj[k].push(newValue);
};
var getPath = (object, path) => {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj) return void 0;
  if (!Object.prototype.hasOwnProperty.call(obj, k)) return void 0;
  return obj[k];
};
var getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
var deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString(target[prop]) || target[prop] instanceof String || isString(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
var regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
var escape = (data) => {
  if (isString(data)) {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
};
var RegExpCache = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
var looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0) return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
};
var deepFind = (obj, path, keySeparator = ".") => {
  if (!obj) return void 0;
  if (obj[path]) {
    if (!Object.prototype.hasOwnProperty.call(obj, path)) return void 0;
    return obj[path];
  }
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
var getCleanedCode = (code) => code?.replace("_", "-");
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
var Logger = class _Logger {
  constructor(concreteLogger, options = {}) {
    this.init(concreteLogger, options);
  }
  init(concreteLogger, options = {}) {
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log(...args) {
    return this.forward(args, "log", "", true);
  }
  warn(...args) {
    return this.forward(args, "warn", "", true);
  }
  error(...args) {
    return this.forward(args, "error", "");
  }
  deprecate(...args) {
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString(args[0])) args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new _Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new _Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event, ...args) {
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach(([observer, numTimesAdded]) => {
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
var ResourceStore = class extends EventEmitter {
  constructor(data, options = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key, options = {}) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (isString(key) && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value, options = {
    silent: false
  }) {
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources, options = {
    silent: false
  }) {
    for (const m in resources) {
      if (isString(resources[m]) || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite, options = {
    silent: false,
    skipCopy: false
  }) {
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};
var PATH_KEY = Symbol("i18next/PATH_KEY");
function createProxy() {
  const state = [];
  const handler = /* @__PURE__ */ Object.create(null);
  let proxy;
  handler.get = (target, key) => {
    proxy?.revoke?.();
    if (key === PATH_KEY) return state;
    state.push(key);
    proxy = Proxy.revocable(target, handler);
    return proxy.proxy;
  };
  return Proxy.revocable(/* @__PURE__ */ Object.create(null), handler).proxy;
}
function keysFromSelector(selector, opts) {
  const {
    [PATH_KEY]: path
  } = selector(createProxy());
  return path.join(opts?.keySeparator ?? ".");
}
var checkedLoadedFor = {};
var shouldHandleAsObject = (res) => !isString(res) && typeof res !== "boolean" && typeof res !== "number";
var Translator = class _Translator extends EventEmitter {
  constructor(services, options = {}) {
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key, o = {
    interpolation: {}
  }) {
    const opt = {
      ...o
    };
    if (key == null) return false;
    const resolved = this.resolve(key, opt);
    if (resolved?.res === void 0) return false;
    const isObject = shouldHandleAsObject(resolved.res);
    if (opt.returnObjects === false && isObject) {
      return false;
    }
    return true;
  }
  extractFromKey(key, opt) {
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    let namespaces = opt.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !opt.keySeparator && !this.options.userDefinedNsSeparator && !opt.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces: isString(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, o, lastKey) {
    let opt = typeof o === "object" ? {
      ...o
    } : o;
    if (typeof opt !== "object" && this.options.overloadTranslationOptionHandler) {
      opt = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof opt === "object") opt = {
      ...opt
    };
    if (!opt) opt = {};
    if (keys == null) return "";
    if (typeof keys === "function") keys = keysFromSelector(keys, {
      ...this.options,
      ...opt
    });
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = opt.returnDetails !== void 0 ? opt.returnDetails : this.options.returnDetails;
    const keySeparator = opt.keySeparator !== void 0 ? opt.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], opt);
    const namespace = namespaces[namespaces.length - 1];
    let nsSeparator = opt.nsSeparator !== void 0 ? opt.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const lng = opt.lng || this.language;
    const appendNamespaceToCIMode = opt.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(opt)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(opt)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, opt);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = opt.joinArrays !== void 0 ? opt.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
    const hasDefaultValue = _Translator.hasDefaultValue(opt);
    const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, opt) : "";
    const defaultValueSuffixOrdinalFallback = opt.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, opt.count, {
      ordinal: false
    }) : "";
    const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
    const defaultValue = needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] || opt[`defaultValue${defaultValueSuffix}`] || opt[`defaultValue${defaultValueSuffixOrdinalFallback}`] || opt.defaultValue;
    let resForObjHndl = res;
    if (handleAsObjectInI18nFormat && !res && hasDefaultValue) {
      resForObjHndl = defaultValue;
    }
    const handleAsObject = shouldHandleAsObject(resForObjHndl);
    const resType = Object.prototype.toString.apply(resForObjHndl);
    if (handleAsObjectInI18nFormat && resForObjHndl && handleAsObject && noObject.indexOf(resType) < 0 && !(isString(joinArrays) && Array.isArray(resForObjHndl))) {
      if (!opt.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, resForObjHndl, {
          ...opt,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(opt);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(resForObjHndl);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in resForObjHndl) {
          if (Object.prototype.hasOwnProperty.call(resForObjHndl, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            if (hasDefaultValue && !res) {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                defaultValue: shouldHandleAsObject(defaultValue) ? defaultValue[m] : void 0,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            } else {
              copy2[m] = this.translate(deepKey, {
                ...opt,
                ...{
                  joinArrays: false,
                  ns: namespaces
                }
              });
            }
            if (copy2[m] === deepKey) copy2[m] = resForObjHndl[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, opt, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = opt.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...opt,
            keySeparator: false
          });
          if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, opt.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(opt.lng || this.language);
        } else {
          lngs.push(opt.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, opt);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, opt);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, opt);
              if (needsZeroSuffixLookup && opt[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, opt[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, opt, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) {
        res = `${namespace}${nsSeparator}${key}`;
      }
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}${nsSeparator}${key}` : key, usedDefault ? res : void 0, opt);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(opt);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, opt, resolved, lastKey) {
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...opt
      }, opt.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!opt.skipInterpolation) {
      if (opt.interpolation) this.interpolator.init({
        ...opt,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...opt.interpolation
          }
        }
      });
      const skipOnVariables = isString(res) && (opt?.interpolation?.skipOnVariables !== void 0 ? opt.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = opt.replace && !isString(opt.replace) ? opt.replace : opt;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, opt.lng || this.language || resolved.usedLng, opt);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) opt.nest = false;
      }
      if (!opt.lng && resolved && resolved.res) opt.lng = this.language || resolved.usedLng;
      if (opt.nest !== false) res = this.interpolator.nest(res, (...args) => {
        if (lastKey?.[0] === args[0] && !opt.context) {
          this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return this.translate(...args, key);
      }, opt);
      if (opt.interpolation) this.interpolator.reset();
    }
    const postProcess = opt.postProcess || this.options.postProcess;
    const postProcessorNames = isString(postProcess) ? [postProcess] : postProcess;
    if (res != null && postProcessorNames?.length && opt.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(opt)
        },
        ...opt
      } : opt, this);
    }
    return res;
  }
  resolve(keys, opt = {}) {
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString(keys)) keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k, opt);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = opt.count !== void 0 && !isString(opt.count);
      const needsZeroSuffixLookup = needsPluralHandling && !opt.ordinal && opt.count === 0;
      const needsContextHandling = opt.context !== void 0 && (isString(opt.context) || typeof opt.context === "number") && opt.context !== "";
      const codes = opt.lngs ? opt.lngs : this.languageUtils.toResolveHierarchy(opt.lng || this.language, opt.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, opt);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, opt.count, opt);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              finalKeys.push(key + pluralSuffix);
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator || "_"}${opt.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                if (opt.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                finalKeys.push(contextKey + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, opt);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key, options = {}) {
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails(options = {}) {
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p = code.split("-");
    if (p.length === 2) return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (isString(code) && code.indexOf("-") > -1) {
      let formattedCode;
      try {
        formattedCode = Intl.getCanonicalLocales(code)[0];
      } catch (e) {
      }
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngScOnly = this.getScriptPartFromCode(code);
        if (this.isSupportedCode(lngScOnly)) return found = lngScOnly;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes((fallbackCode === false ? [] : fallbackCode) || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c) return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (isString(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
var dummyRule = {
  select: (count) => count === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
var PluralResolver = class {
  constructor(languageUtils, options = {}) {
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code, options = {}) {
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key, options = {}) {
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code, options = {}) {
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count, options = {}) {
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count, options);
  }
};
var deepFindWithDefaults = (data, defaultData, key, keySeparator = ".", ignoreJSONStructure = true) => {
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && isString(key)) {
    path = deepFind(data, key, keySeparator);
    if (path === void 0) path = deepFind(defaultData, key, keySeparator);
  }
  return path;
};
var regexSafe = (val) => val.replace(/\$/g, "$$$$");
var Interpolator = class {
  constructor(options = {}) {
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options?.interpolation?.format || ((value) => value);
    this.init(options);
  }
  init(options = {}) {
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$1,
      escapeValue,
      useRawValueToEscape,
      prefix,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$1 !== void 0 ? escape$1 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc, options = {}) {
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      const keyEndIndex = /{.*}/.test(match[1]) ? match[1].lastIndexOf("}") + 1 : match[1].indexOf(this.formatSeparator);
      if (keyEndIndex !== -1) {
        formatters = match[1].slice(keyEndIndex).split(this.formatSeparator).map((elem) => elem.trim()).filter(Boolean);
        match[1] = match[1].slice(0, keyEndIndex);
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString(value)) return value;
      if (!isString(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (formatters.length) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
var parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
var createCachedFormatter = (fn) => {
  const cache = {};
  return (v, l, o) => {
    let optForCache = o;
    if (o && o.interpolationkey && o.formatParams && o.formatParams[o.interpolationkey] && o[o.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [o.interpolationkey]: void 0
      };
    }
    const key = l + JSON.stringify(optForCache);
    let frm = cache[key];
    if (!frm) {
      frm = fn(getCleanedCode(l), o);
      cache[key] = frm;
    }
    return frm(v);
  };
};
var createNonCachedFormatter = (fn) => (v, l, o) => fn(getCleanedCode(l), o)(v);
var Formatter = class {
  constructor(options = {}) {
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.init(options);
  }
  init(services, options = {
    interpolation: {}
  }) {
    this.formatSeparator = options.interpolation.formatSeparator || ",";
    const cf = options.cacheInBuiltFormats ? createCachedFormatter : createNonCachedFormatter;
    this.formats = {
      number: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: cf((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: cf((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: cf((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: cf((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng, options = {}) {
    const formats = format.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f) => f.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f) => f.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
var removePending = (q, name) => {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
};
var Connector = class extends EventEmitter {
  constructor(backend, store, services, options = {}) {
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err) q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l]) loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0) loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName, tried = 0, wait = this.retryTimeout, callback) {
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces, options = {}, callback) {
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name, prefix = "") {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate, options = {}, clb = () => {
  }) {
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
var get = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString(args[1])) ret.defaultValue = args[1];
    if (isString(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  },
  cacheInBuiltFormats: true
});
var transformOptions = (options) => {
  if (isString(options.ns)) options.ns = [options.ns];
  if (isString(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  if (typeof options.initImmediate === "boolean") options.initAsync = options.initImmediate;
  return options;
};
var noop = () => {
};
var bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
var I18n = class _I18n extends EventEmitter {
  constructor(options = {}, callback) {
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init(options = {}, callback) {
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (options.defaultNS == null && options.ns) {
      if (isString(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      const usingLegacyFormatFunction = this.options.interpolation.format && this.options.interpolation.format !== defOpts.interpolation.format;
      if (usingLegacyFormatFunction) {
        this.logger.deprecate(`init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting`);
      }
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        if (s.formatter.init) s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init) s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", (event, ...args) => {
        this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init) m.init(this);
      });
    }
       this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = (...args) => this.store[fcName](...args);
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = (...args) => {
        this.store[fcName](...args);
        return this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language, callback = noop) {
    let usedCallback = callback;
    const usedLng = isString(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode") return;
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append(l));
      } else {
        append(usedLng);
      }
      this.options.preload?.forEach?.((l) => append(l));
      this.services.backendConnector.load(toLoad, this.options.ns, (e) => {
        if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages) return;
    if (["cimode", "dev"].indexOf(l) > -1) return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
    if (!this.resolvedLanguage && this.languages.indexOf(l) < 0 && this.store.hasLanguageSomeTranslations(l)) {
      this.resolvedLanguage = l;
      this.languages.unshift(l);
    }
  }
  changeLanguage(lng, callback) {
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        if (this.isLanguageChangingTo === lng) {
          setLngProps(l);
          this.translator.changeLanguage(l);
          this.isLanguageChangingTo = void 0;
          this.emit("languageChanged", l);
          this.logger.log("languageChanged", l);
        }
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve((...args) => this.t(...args));
      if (callback) callback(err, (...args) => this.t(...args));
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const fl = isString(lngs) ? lngs : lngs && lngs[0];
      const l = this.store.hasLanguageSomeTranslations(fl) ? fl : this.services.languageUtils.getBestMatchFromCodes(isString(lngs) ? [lngs] : lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language) this.translator.changeLanguage(l);
        this.services.languageDetector?.cacheUserLanguage?.(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    const fixedT = (key, opts, ...rest) => {
      let o;
      if (typeof opts !== "object") {
        o = this.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        o = {
          ...opts
        };
      }
      o.lng = o.lng || fixedT.lng;
      o.lngs = o.lngs || fixedT.lngs;
      o.ns = o.ns || fixedT.ns;
      if (o.keyPrefix !== "") o.keyPrefix = o.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = this.options.keySeparator || ".";
      let resultKey;
      if (o.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => {
          if (typeof k === "function") k = keysFromSelector(k, {
            ...this.options,
            ...opts
          });
          return `${o.keyPrefix}${keySeparator}${k}`;
        });
      } else {
        if (typeof key === "function") key = keysFromSelector(key, {
          ...this.options,
          ...opts
        });
        resultKey = o.keyPrefix ? `${o.keyPrefix}${keySeparator}${key}` : key;
      }
      return this.t(resultKey, o);
    };
    if (isString(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t(...args) {
    return this.translator?.translate(...args);
  }
  exists(...args) {
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns, options = {}) {
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString(ns)) ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    try {
      const l = new Intl.Locale(lng);
      if (l && l.getTextInfo) {
        const ti = l.getTextInfo();
        if (ti && ti.direction) return ti.direction;
      }
    } catch (e) {
    }
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get());
    if (lng.toLowerCase().indexOf("-latn") > 1) return "ltr";
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(options = {}, callback) {
    const instance2 = new _I18n(options, callback);
    instance2.createInstance = _I18n.createInstance;
    return instance2;
  }
  cloneInstance(options = {}, callback = noop) {
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new _I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      const clonedData = Object.keys(this.store.data).reduce((prev, l) => {
        prev[l] = {
          ...this.store.data[l]
        };
        prev[l] = Object.keys(prev[l]).reduce((acc, n) => {
          acc[n] = {
            ...prev[l][n]
          };
          return acc;
        }, prev[l]);
        return prev;
      }, {});
      clone.store = new ResourceStore(clonedData, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    if (options.interpolation) clone.services.interpolator = new Interpolator(mergedOptions);
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", (event, ...args) => {
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

export {
  keysFromSelector,
  instance,
  createInstance,
  dir,
  init,
  loadResources,
  reloadResources,
  use,
  changeLanguage,
  getFixedT,
  t,
  exists,
  setDefaultNamespace,
  hasLoadedNamespace,
  loadNamespaces,
  loadLanguages
};
//# sourceMappingURL=chunk-MOZ4RPRG.js.map
           9:      isString   N#9      obj    ]      defer      :0      res    :#      rej    mB
      makeString           copy   jz      lastOfPathSeparatorRegExp      h<      ###	    R      cleanKey
   B;      key    E      indexOf    #Y      canNotTraverseDeeper   F      getLastOfPath      ":k      path   )      Empty      ?6G
      stackIndex     ;	-      hasOwnProperty     =      setPath    z3      newValue          slice            last   @_      pushPath   u2      push   Lb6      getPath    A      getPathWithDefaults    6(      data   tM      defaultData    .tZ
      deepExtend     ^W	      overwrite      P      prop   8$      regexEscape     61      str!    O"      [\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]"     {S8      \$&#    
      _entityMap$           &amp;%      a @      &lt;&         &gt;'   ~      &quot;(     &Q       &#39;)      {F&      &#x2F;*     +	      [&<>"'\/]+      9Jx      RegExpCache,    /      capacity-   T	      regExpMap.      2m      regExpQueue/    3	      getRegExp0      A      regExpFromCache1    Qp	      regExpNew2      =O      shift3      _q      chars4      4=      looksLikeObjectPathRegExpCache5     "      looksLikeObjectPath6    YT      nsSeparator7    5!      keySeparator8   	      possibleChars9      >	      filter:     9      map;    u      \?<     >      join=   G      matched>    Y	      substring?      cx      deepFind@   8      tokensA           currentB    i&c      nextPathC   i;      getCleanedCodeD     hc)      codeE   w      consoleLoggerF      Y      loggerG     =X      logH          argsI   [>      outputJ     M      warnK   Q1      consoleL    n,      LoggerM     Z      _LoggerN    9      concreteLoggerO      :y      optionsP    u`      initQ   2      prefixR     d4      i18next:S   .`      debugT      8+      forwardU    &w`	      deprecateV      I}G      WARNING DEPRECATED: W   ")      lvlX    
	      debugOnlyY      :	#      createZ     .Qi&
      moduleName[     4      clone\      9g5
      baseLogger]           EventEmitter^   N^W	      observers_      Q(      events`     l%      listenera   IIP      eventb      X~C      numListenersc         offd    (|V      emite         clonedf     Uyh      observerg   -H      numTimesAddedh            ResourceStorei      E      translationj    ,#(	      defaultNSk      z      ignoreJSONStructurel    Gk      addNamespacesm      x1      removeNamespacesn   g      spliceo     2\      getResourcep    h`      lngq    ]      isArrayr    ]EG      addResources    )>(      silentt     ?      addedu      C+      addResourcesv   V	      resourcesw      h      addResourceBundlex      /'       deepy   
d      skipCopyz   (      pack{   5      parse|      n	      stringify}      <      removeResourceBundle~         hasResourceBundle      \5      removed    ,`m      getResourceBundle      K      getDataByLanguage      6"      hasLanguageSomeTranslations    {AH      postProcessor      
      processors           addPostProcessor   v%      handle     u1
      translator     y|	      processor      8J      process    Y      PATH_KEY   o      i18next/PATH_KEY   gxS      createProxy    G      state      Z`      handler    z	      revocable      H      keysFromSelector    _l$      selector   G      opts   i      checkedLoadedFor   >      shouldHandleAsObject   c
      Translator     o\      _Translator    t      services   F      resourceStore      Z      languageUtils      8      pluralResolver     /p      interpolator         backendConnector   
      i18nFormat     k
q      utils      w      changeLanguage     Q      exists     o      interpolation      <]FO      opt    *A      resolved   t      isObject   T3      returnObjects      (^M      extractFromKey     <0
      namespaces     L      wouldCheckForNsInKey   z      seemsNaturalLanguage   bz      userDefinedKeySeparator    D      userDefinedNsSeparator     )      nestingRegexp      !T      parts      uU~1	      translate      2      lastKey           overloadTranslationOptionHandler   E      returnDetails      [2	      namespace      CE      appendNamespaceToCIMode    RDo      toLowerCase          cimode     9N      usedKey    G,      exactUsedKey         usedLng    Vg]      usedNS     g
      usedParams     5S      getUsedParamsDetails   )
      resUsedKey     ^      resExactUsedKey    <      noObject   9@
      joinArrays     	O      handleAsObjectInI18nFormat     W      handleAsObject           needsPluralHandling    E      hasDefaultValue    i      defaultValueSuffix     CT	      getSuffix      7$^!      defaultValueSuffixOrdinalFallback            ordinal    U{3      needsZeroSuffixLookup            defaultValue         pluralSeparator    wg      resForObjHndl      +8L      resType    d      returnedObjectHandler      oH?      accessing an object - but returnObjects options is not enabled!    l      key '      $       (     +,(      )' returned an object instead of string.   G      resTypeIsArray     dE      copy2      T      newKeyToUse    %      deepKey    V0      extendTranslation      +S      usedDefault    ER      isValidLookup      x      missingKeyNoValueFallbackToKey     '(      resForMissing            updateMissing      wB	      updateKey      SQ+
      missingKey     8      Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.    5      lngs   W      fallbackLngs   R~      getFallbackCodes         fallbackLng          saveMissingTo      J      fallback   &fM      toResolveHierarchy     ,      send   -]      specificDefaultValue   O      defaultForMissing      ~_      missingKeyHandler      (      saveMissing    b~      saveMissingPlurals     ^{      suffixes   l%      getSuffixes    %[      suffix     c      appendNamespaceToMissingKey          parseMissingKeyHandler     U      defaultVariables   o      skipInterpolation      G      skipOnVariables    i      nestBef    @oQ      interpolate          nestAft    ?m      nest         context    *      It seems you are nesting recursively key:      G5	       in key:       W      reset      K      postProcess    c V      postProcessorNames     Qd      applyPostProcessor     42      postProcessPassResolved    c      i18nResolved  W58      found     7~	      extracted     A
      fallbackNS    J]5
      needsContextHandling        codes     E      hasLoadedNamespace    A      key "     o`      " for languages "	     ^v      , 
    cR#      " won't get resolved as namespace "   4^      " was not yet loaded  StT      This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!  	      finalKeys     k[      addLookupKeys      U      pluralSuffix  {P+
      zeroSuffix          ordinalPrefix     \
      contextKey    H$I      contextSeparator  }      possibleKey   i4      pop   ;B
      returnNull    v      returnEmptyString     B      optionsKeys   X      useOptionsReplaceForData  |`      option    j      LanguageUtil  t      supportedLngs     sw      getScriptPartFromCode     m      formatLanguageCode    8      getLanguagePartFromCode    Q*      formattedCode!     4      getCanonicalLocales"   3mx      lowerCaseLng#  <	      cleanCode$     iT[      isSupportedCode%   2U)      load&        languageOnly'  ~      nonExplicitSupportedLngs(  r,      getBestMatchFromCodes)     fm
      cleanedLng*    k<T	      lngScOnly+     G-      lngOnly,   w2      supportedLng-  	      fallbacks.     _y      fallbackCode/  9,3      fallbackCodes0     C-c      addCode1   :4      rejecting language code not found in supportedLngs: 2  r*w_      currentOnly3         suffixesOrder4     }	      dummyRule5     1<      select6    D41      resolvedOptions7   M      pluralCategories8  2'X      PluralResolver9          pluralRulesCache:  b      addRule;   :      rules<     
      clearCache=    (      getRule>   7YZ      cleanedCode?   f7      dev@   	t      cardinalA        cacheKeyB        ruleC  o      errD   zdd-      No Intl support, please use an Intl polyfill!E     }5c      -|_F   ~(      lngPartG   (      needsPluralH   F      getPluralFormsOfKeyI   }      sortJ  K[      pluralCategory1K   j$      pluralCategory2L   "kG      pluralCategoryM    $      prependN   Wn      no plural rule found for: O    T      deepFindWithDefaultsP  .f	      regexSafeQ     &      valR   hO      \$S    ^      $$$$T  /      InterpolatorU        formatV    K      escapeValueW         escape$1X  5wG      useRawValueToEscapeY   L1      prefixEscapedZ     JB      suffixEscaped[     ?1      formatSeparator\   G      unescapeSuffix]    5F6      unescapePrefix^    z      nestingPrefix_           nestingPrefixEscaped`  m      nestingSuffixa     ^0      nestingSuffixEscapedb        nestingOptionsSeparatorc         maxReplacesd   VDJ      alwaysFormate  r&      {{f    `d      }}g    `      $t(h         resetRegExpi   %      getOrResetRegExpj  n)I      existingRegExpk    *m2      regexpl    ?      (.+?)m     UD      regexpUnescapen    $g?      ((?:[^()"']+|"[^"]*"|'[^']*'|\((?:[^()]|"[^"]*"|'[^']*')*\))*?)o   V      replacesp  U      handleFormatq  X      interpolationkeyr  b      trims  IK	      missingInterpolationHandlert         todosu     cT      regexv     b	      safeValuew     /      todox  t
      matchedVary    
      tempz  c      missed to pass in variable {   c       for interpolating |         clonedOptions}     Y      handleHasOptions~  x      inheritedOptions  u?0      sep   ~"      [ ]*{     9      optionsString     kyQ#      matchedSingleQuotes   Q3      matchedDoubleQuotes   W\1      failed parsing options string in nesting for key      u_
      formatters    |U      keyEndIndex   2      {.*}        lastIndexOf   d!      elem  >      missed to resolve     7W       for nesting      ?
      reduce    g      parseFormatStr    !e{	      formatStr     | 
      formatName    X8      formatOptions     p      optStr          relativetime  n3B      rest  h      ^'+|'+$   :#
      trimmedKey    e      createCachedFormatter     
,      cache     r      optForCache   yI=      formatParams  \7      frm   h.	      createNonCachedFormatter  xm	      Formatter     w|p	      formatter           cacheInBuiltFormats   y      formats   	      datetime        list  JP	      addCached     *"V      mem   A	      formatted     ;D
      valOptions    \X!      there was no format function for            removePending     s)      pendingCount  _'>	      Connector     zM      backend   N/      store           waitingReads  xCr      maxParallelReads  F]      readingCalls  C6
      maxRetries    )/      retryTimeout  p#      queue     tD	      queueLoad     }	      languages           callback  [j      toLoad    /|N      toLoadLanguages   G      toLoadNamespaces  Ed      hasAllNamespaces  MT      reload    M      loaded    0c]e      failedLoading     o
      loadedKeys    b      fcName    {.      tried     V;      wait  v      resolver  3At
      setTimeout          bind  }B      prepareLoading    	>      No backend was added via i18next.use. Will not load resources.    ,D      loadOne   J	      loading namespace     ]       for language     Kr       failed   X      loaded namespace             fallbackValue     5V      isUpdate  O      clb   &~      did not save key "    *      " as the namespace "  :8	      initAsync           preload   pn=      simplifyPluralSuffix  &!z      partialBundledLanguages   tN      ret          tDescription  4l      transformOptions  iHV      initImmediate     17      noop        bindMemberFunctions   q9      inst  ,om      mems  9*B?      getOwnPropertyNames   8t      I18n  2g      _I18n     IV      modules   &'g      external        isInitialized           isClone         isInitializing    o      defOpts   T3      createClassOnDemand   s9      ClassOrObject           usingLegacyFormatFunction     R      init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting    ~      languageDetector  L	      detection     X7      init: no languageDetector is used and no lng is defined   P|      storeApi  `      storeApiChained   ;D      deferred  |4      finish    h6      initializedStoreOnce   uE      init: i18next is already initialized. You should call init just once!           initialized   |M      loadResources     o]~      usedCallback  B-      append    CV      resolvedLanguage  f@j      setResolvedLanguage   Z      reloadResources   vZ      use   Ya<]      You are passing an undefined module! Please check the object you are passing to i18next.use()     fX      You are passing a wrong module! Please check the object you are passing to i18next.use()  K      3rdParty  	      lngInLngs     Yl      unshift   {      isLanguageChangingTo  ;      languageChanging   E      setLngProps   
qk      languageChanged   E      setLng    Lu|3      cacheUserLanguage     mK      detect    +X 	      getFixedT     W-c	      keyPrefix     '|      fixedT    )x	      resultKey	     %m      setDefaultNamespace
   L/      hasLoadedNamespace: i18next was not initialized   ZK4~:      hasLoadedNamespace: i18n.languages were undefined or empty    s	      lastLng   _      loadNotPending    #,>f	      loadState     =      precheck  X	      preResult     Rb      loadNamespaces    3[      loadLanguages     T	      preloaded     =\      newLngs   a      dir   lg      rtl         getTextInfo   a      rtlLngs   u      shu   >      sqr         ssh         xaa   kD+      yhd   v<      yud   f      aao    u      abh!   vS      abv"   P      acm#    e      acq$   O      acw%   AH      acx&   V      acy'   K5w      adf(         ads)   r>      aeb*   :      aec+   UzB      afb,   m      ajp-   aR      apc.   L      apd/         arb0   p      arq1   +      ars2   8x      ary3   cz      arz4         auz5         avl6   fsm      ayh7   %      ayl8          ayn9         ayp:   F_)      bbz;   ~Y      pga<         pbt=   e(,      pbu>         pst?   '1+      prp@   a      prdA   PqA      yddB   ~      ydsC   %J"      yihD   v,      hboE   {{      menF   q3      xmnG         jprH   x*      peoI   <      pesJ         prsK         samL   R      ckbM   f      -latnN     S      ltrO   n      -arabP     *M      createInstanceQ    LF	      instance2R     &#      cloneInstanceS     C8      forkResourceStoreT     y_      mergedOptionsU     ?O      membersToCopyV     	
      clonedDataW    >"      prevX        accY         instanceZ  Y@9      defer/promise<[    t[      copy/<\    x      escape/<]  "      looksLikeObjectPath/possibleChars<^    b      looksLikeObjectPath/r<_    WI      on/<`  2      emit/<a    k      hasLanguageSomeTranslations/<b     ;      handle/<c  W      createProxy/handler.gete   1      translate/<f   "      translate/</<g     g      extendTranslation/res<h    C	      resolve/<i     d      resolve/</<j   s9>      resolve/</</<k     Q      getBestMatchFromCodes/<l    N      getBestMatchFromCodes/</found<n          toResolveHierarchy/<o  .      getPluralFormsOfKey/<p     _j6J      getSuffixes/<q     >L_      Interpolator/this.format<u     N,      interpolate/<w     u      nest/formatters<x  7k      nest/value<y   {      parseFormatStr/<z  .      createCachedFormatter/<{   cT      createNonCachedFormatter/<|    x      init/this.formats.number<}     5      init/this.formats.number</<~   p`      init/this.formats.currency<   d      init/this.formats.currency</<     
3<      init/this.formats.datetime<         init/this.formats.datetime</<     yn      init/this.formats.relativetime<   !      init/this.formats.relativetime</<     h^E      init/this.formats.list<   ]      init/this.formats.list</<     %      format/<  zN      format/lastIndex<     I      format/result<          queueLoad/<   a      queueLoad/</<           loaded/<  
      loaded/</<    5M      loaded/</</<  Jx      loaded/this.queue<    /       read/resolver/<         read/<    Z      prepareLoading/<  'fo]	      loadOne/<     %ad      saveMissing/<     r&      get/overloadTranslationOptionHandler/<    =      bindMemberFunctions/<     D      _I18n/<   M      init/<    ,      init/</this[fcName]   x/      loadResources/append/<    #`      loadResources/<         reloadResources/<     '!      changeLanguage/done/<     ar      changeLanguage/setLng/<   3      getFixedT/fixedT/resultKey<   ,:L      loadNamespaces/<  EU      loadLanguages/newLngs<    j      loadLanguages/<   ?AP      cloneInstance/<   5      cloneInstance/clonedData<     .
"      cloneInstance/clonedData</prev[l]<        =	  }     
       i   %,        D                                                                                                                                                                                  	      
                                             
                                                                                                                                                                                                                                                                                                                                                                                  "                #                $                %                                                                                                                          ,                 ,                 ,                 ,                  ,           !      ,           "      ,           #      ,           $      ,           %                  &                 '      7           (      8                             )                 *      ;                <           +      =                ;                ?           ,      @                            -                  .                  /      D                            0      F                            1      H                            2      J                            3      L                            4                  5                  6                  7                  8      R               S           9                  :                  ;                 <      W           =                  >      Y                Z           ?                  @      \                             A                      _           B      _           C      _           D      b                _           E      d                e                _          F      g               h                h                j                k                h               m               n                n                n           G      q                 n          H      s                 t           I      _          J      v                 w                x                x                x           K      _          L      |      	         }           M      ~       	                   N                 O                                                       _           P      _           Q      _           R                                      _           S                                                   T                  U                                  V                                  W                                                  X                 Y                                 Z                                  [                                 \                  ]                                 ^                                 _                 `                  a                  b                  c                  d                  e                  f                                                                  g                                 h                 i                 j                                 k                 l                  m                                  n                                  o                  p                 q                  r                                  s                  t                                 u                 v                                 w                                                  x                 y                 z                                                  {                                |                                                                  }                 ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      	                                        	                                                                                                                                                                                                                                                                                                            	                               	                               "                #               $               %                "                                                                     *                +                                -               .                -               0              1                1               3                3                3                1               1               8                1               :                1                <                =                -               ?              @              A                B                C                A               E                A                A                -               I              J                -                -                M               N               -               P               Q                Q                S                S                Q                V               W                -               Y               Z               [               \                -                -                -                -               a               b                c                b               -               f               g                g                -               j               k                k                -                n               o               p               o               -                s               -               u              v                v               x               y                v                -                OcD          C   C   D   Y P  P  P]   P P3  P  P  P	  P+    P#  PE  P PP P P P  P Pt `3 P5  PP  P P8 P  P  P\  P PP P  P P P P?  P P  PL    P   P  `  PO P  P P	 P  PT P4  P  P  P  P  Ph  P  P  P  P P4 P P  ` PC  P  P P `                                             P  Px                                               a  s `B`             m               
                                                                 
                                 e  p      k                     <                  k                                  k                   
                                                                                               s              ,  t               p  t                0  1               
  6  P7  P            =  8  r               c               c                               7              A  @              i              A  B     	         j               D              H  t               H  t               H  t                  H               M  P           N  O  t              N  O  t               H  t               H  t               H  t               H  t               H  W  Q  X  t               Z  t               O  t                 t                _  `  Pt  `             a               b              a  `  t               a  PH  Pt                e                  f  g              i               e                  f  g              i               O  t   p                t                t                              p   
  O  t      	           7  k               p   
    O  t                 7             p   v  O  t                m             p   v  x    O  t      	           z              p   t               p   t               p   t               p  t               p  t                  Pn               v                t               /  t                   `
  PO  P  Pt  `                                            | `  P  P               
                                                                P             O  t   p               p  t              
  o  t                                  
    t               6    7                   m                   o       t  `                P  P6    P  P        P    7    P        
  P    p                     r                                  m                                     P  P                  P                          i               l  k                                  `                                             
  P  P    Pt  `                                                                              H                  Pt  `             P  P  P  P  P             k                 
  P  P  P P P             `             D                                                           t              D   
  O  t              O  t                                
               O               Q                            O  t               D  t                p              D  t                p              D  t                             e              D  t                 t  `              P             D               )              D               * + P             ,             - D  t                             D  . t  `             /  P0 P             c                             F                                O  t               p    t                 t              D  O  t               B >   A             C    	          F            D  O  t               B            D  
  PO  t                             D  O  Pt  `            B              J K              L            D  F   O  t                B                
  7  k                             Q            O  t                             O  t                W V X Q  Y   Z [ \ ] ^ _ ` a b c d               t                 t                i              j p                  P  Pp  PO  Pt  `             ` `o P  Pp Ps P  Pt              
               p  k  f                              Q              Q              w              x v              y                O  Pt  `             `  | P}              
  ~               c                e                                           v  f                              P             p                                              
   Q               `               P             v  l  o                
               `             v  l  o             O  t                O  t                              p                   P             Q              p                   P             Q              p                   P             Q              p    P               P             Q              p                   P             Q             8   t               8   t                U p  PO  Pt  `                             f                              f                f                                            l                              q  8                 O  t   p                   PO  P t  `               Pr ` P P             p  P              P                           8              8 `C P  t                s  p  P` P             q `             l `                           n               q              p  P` P P P Pt  `              P              C                A                               r                             C               O   t  `                           8                  t                   t               8 `Q  Pt  `             s  p  P`             C                 
    O   Pt                      	                
         r                    
         C                              H                P              O  P             
                              O                                P                                          P           O  P Pt  `p                              O   Pt  `                  P%                  
          ^ s                a  H               a  H               m                              P             H                P             H                                             C B                t  `             P                P P             p                              l               -              l               l               e                  Pt                 P             C             /  t               l  t               R                            p  P Pt  `              P  Pj  `              l               C l               H               H                               l `             C              p    Pt  `               P             
    P             o ` 7  P             k              H  t               H  t                t               O  t  `             p                   l  n                                             Pt  `               P             n               C                 Pt  `              P P              p               C             p  t                                l               R             e             O                Q            O   t  `             S T [  PU              m               V              W Pl `             X n               a  H                t   0     !     *     E     R    '     "     '              I$KE                           
     k     6    &  $  <  %  >  &  "  '  '  (  /  )      -               ,      ?      !      ;            G  J     I                        Q             
     j                           s          s          s     
     s  y                                                                  
    
       
    
                                                                     
          
                                                                      N          f                         h         
    5 6        7                                    
     >                                                                  V            
    u v    
    u v                    
                                                    G                                                                              r                        r             y                                   p                                         #       S    j      ' %   7  6                s                                   7      V U Q    [ ] ^ ` b c                                               
   M                                                                             O        &!!          @                      o    )  o    5  o      o      n    :  o      o    A  o    +  o	    0  o
      o      o      o    9  o    3  <      o    >  : o   @   ?   o   ?     <    	        2  o      o    %  o    @  ;      >   o   >   o   >    o!   >"   o#   >$      %   : o&   @   ?   o'   ?(   o)   ?   o*   ?    o+   ?"   o,   ?-   o.   ?/   o0   ?1   o2   ?3                 : o4   @   ?   o5   ?6   o7   ?8   o9   ?:         r   C   L      D   tE   =s;   @   ?   o<   ?=   o>   ??   o@   ?A   oB   ?C   oD   ?E   oF   ?G   oH   ?I   oJ   ?K   oL   ?M   oN   ?O   oP   ?Q   oR   ?S    7  ;T   ;U   >V   oW   >X   oY   >Z    '  [    \   u  8  ;_      o`      a      r   l   L      m   tn   =sb   @   ?   oc   ?d   oe   ?f   og   ?h   oi   ?j   ok   ?l   om   ?n   oo   ?p   oq   ?A   or   ?s   ot   ?u       -  : ov   @   ?   ow   ?x   oy   ?z   o{   ?|   o}   ?~   o   ?   o   ?   o   ?    "  <      ;   o   >   o   >    <  : o   @   ?   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?      o    ,  o      : o   @   ?   o   ?(   o   ?   o   ?   o   ?   o   ?    1  o    ;  o    #  o    ?  : o   @   ?   o   ?(   o   ?   o   ?   o   ?    =  o    B     r      L         t   =s   @   ?   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?      o    *  o    4  o    .  o            r      L         t   =s   @   ?   o   ?(   o   ?   o   ?   o   ?   o   ?   o   ?d   o   ?   o   ?   o   ?f   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?   o   ?S          L   u        L          L         L(         L         L         L         Ld    6     L         L         Lf    !     L    /     L    $     L    &     L       `+`K`K`K!`+`+`+`K-`KC`KK`KT`K[`Kk`+`Kt`Kz`@  @  `+&` `K  `K  `+`%*    ` J      J  J  @  ` ` J J @  ``@ /J 4J :J UJ dJ nJ J    J  `%* @ `PI `+`+`e@  J J J J J D  J b
@ l`@ rJ {J J J J J @ `K `%* `@   J J  J @ %`K -`+`@ 5J [ J jJ @ `K `K  `+`@ &J M  @ t`K z``@ J J J J  J J (@ M`K `K ` `K `e@ J 4J SJ fJ J J J    J J "J 2J B
M GJ {@ `P)` ` ` ` ` ` ` ` 	` ` ` ` ` `0 P  %   U  j   a   "        T     ,   uc,                               	`   kU   W                                         o               O         O       '`	H`/`/`T         Q       T          X   zX   )                                                ` ` PX   <;X   %                                            ( ``5F`QX   _X   &                                  L   o   y  `

P4PX   D5X   ,                              M                MQ    	` ` P   m&   \                                    L      u     &        L    :     u             	` P "
P *P   ~,P   !                                  )     u     ` P  LL                  %      $      )    u               L      u                 L   )         A     u    
   ;               Mu       M                         Q      L   L	   L
       u           M        ;           2*       A     u       ;       ;     >            Mu >    *`
P P-`&
f &	`P
`5I`		P(	` `P*	` %P-` `N`@`P
`5H`%(	P8T                o                                       p                             O        \M           
       3      $            +         u gL     L              L                 Q 	     L   )M    L    L   )u    +          u        L           L                L   )M3   (   3(     L     L   )u    +          u     4   #   L      $    $   2   %     L     L   3   (   3(M   ,      -     O   .   .     L     L   3   (   3( Q @`P ` `-`1H	` `
P(`P(
f	 `  +`P(`P(	` 	 
 `@`	 
P                 ~                         V   w                             +         u gL      L               M      j       Q     ML    y  $@`P ` ` PP          v   ,                                  +      u gL      L                    L   L   L        u    
   
        M @`P `` 2H` &P` 2H`T,                C              x                           X   K                                 u                         u  &`P(`
-`4H`PT          J       1              H            c,O  U                      $    `   ab7                                           $       )        Mu N           M   #5       )       Mu           M   #   2                      MQ   '       9        M    M y                   MQ      c   f $	` `.`	P * P 2 `` `P0	 	`@M`Q           P        
   ?  H   +{.H                              L   n      u  	`

P5|   Yf|   8                          )     u "        L   n   o   u       `	P-`
P3F`Q0   70   
                              M `	l   
l   :                              O             O      j    O   &`-`!P)`/P  ;mh                                  L   L     u                             L   L      L   1         L   L      L   L	   u  y       L   L
       y    L   L     y   
*` P(	`-`DH`(	` `  PPI	` 	P$` P$`$T               B                        T  ;"  x        
                                                                	  L   o   u     L             2  L        L   o	   u L
      u 3(   (u     L     u       t          L      u      ,        L     L     u u                       $.` ` `P(` `1H`)P"PP(`P)`
&`
P(	` 
PP `@`TT        e                      j           u         p   Xp   9                            L     u          L     u     `P 'P
T   	 T   +                                                   ` 8  <dh       	          .      $                                                    MK         L   L   L        u    
   
        M     L     u                   L	                                                       L	                       (0           M(0      M          j      k       k      k   L     u     %       L	   )(      )   %   )         )((0     ,     2*  .       g.      #*`` 2H` 	` &P` 2H`9H`P(`)`f *	`  ` 2:&`*
`	f `/	`@` `.`	-` (P ! `J	`	.	`J(`@`@`T8       ?   S      [                                                  
     {        7           8            9           O  &                         ^                `   84`   4                           4#      L         u            
` P 	P   P                                L        y &` P$PP   7i
P                                L        y &` P$PP   hP                                L        y &` P$P   -S   \                            4H        M49      L   4                y            ` 	P P   3   Q   
                                        ;          L        y  `
P$P   }k4      
             
                          ;            L               O                   O       O       L   O    ` ` `.` PX   7X   )                                L           u +`P#QX   7X   )                                L           u +`P#QX   X   (                                L           u +`P#QX   7X   )                                L           u +`P#Q   |                                       L               )     Mu ,         3   L   3(   (  M3(Q      L    M  u &	` `AF	`	P`	 .`P#Q   ~-w   q         	                          L   :;      L   3   (  3(   (>       y    L       y    &`	"&	  @@PCQ   h#   p                                     L            L            L      O            L           &` ` `	P#Q@   3@                                ;   O   &`/Pp   1yp   9                                 L      u L   o   y     `P
PD`%Q   R4                                L     M&         L            Q      L     ML      u                L     ML         (y  &` ` (P*` P ` 
P%P                '7   b                	             L     M                    L     U       L     ML    y &	` `AF	`-`.`AF` P$Px  mH(X                                          L      MR           L      L      ML   u  u     L   o   y       L   L   Q           L      L   L   L   u  u     L   o
   y     	` &` PP(`PJ		` &` PP(`PJPx     8   H   	      G     @                  '      $  ek      L           M                     M   	    	        	   Mw  fL   u  f L                L                5      u  f L                L                    d                            { b      Mw  fL   j           u  f L      "   L   l$       $   $   z  2*  \'    `f/`  PB,`@P  P     /                       
             .          ;       O8                  &      $  ek      L           M                     M   	    	        	   Mw  fL   u  f L                L                5      u  f L                L                    d                        L      j      k       Mw  fL          u  f L      !   L   l#    y   2*  d&    `f/`
 PD,`@P  H     /                       
             .          ;     d  8sRd    
                          7         .      ;   j      k    >      >                           ;      O       O     L   L           L   	   O        L   L
           L   O
           `P.` `/	`-`@
	`%-`@V   ]   O                
             L   L   L     u &         L   L   L     y 
   &	` P/` PIP      b                
              L   L   L     u      (         L   L   L     y 
   &` P(	` ` PJP         [   x  *U(  *     	          Y      $                              ;                  L           L           L   L          L           L           L   L              L      u  '         L      u        j      k      k            	   L
     u         L     { b      Mw  fL   j    !       u  f L      $   L   l&       &   &   z   '    )     u    )     )      *     L     L     u { b   /   Mw  fL   j    3       u  f L      6   L   l8       8   8   z   9     L     y ;         L     u     A   ?     1   A     !   C      L      u  F   D   G     M     M    L   u L      u   M     )   N        P    )     u R      S     S    %     L   4$   U      M4   W     M   X    X       u   `	 !`	 &	` P ` P `	.`.`P-`  P,`	P `
P  P `
PI`	P(	`   P `+`+`P	PM	`
 
P `DH` P#Tx  X     Q                      '                 .         s  .     $|                                                          ;   >              L           L           L   L   	     j      k      k       P        L     !        L     u            u         L   	   u  6         L   	   u         M       L
     y  0     L       y   L   .        L               y      *`	 `	.	`` P P-	` P ` P(`)`@`P$`	P$	` ` P*P     c   |    
Um  <                     $                              ;   >            `   ab           )       Mu #         L       Mu    9        L              M;   >   y    k   c  L   *        L   	          y      f $`		P  	P `	%	FGPIM	` ` P)P       W            b           ,     	          '                                              ;   >   >            j      k      k        L      u  ?   	      L      u             M       L     y       L	     u       ;
          L   1         L      L     u u        %       9         y 7      :      y       y   !    0     L	       y   L   *   %     L             y '    & *`	.	` P ` P(`)`)`@`P$`	P 	` `PP-	`.`P `"	 	@`	P$	` ` P*P      u           h                	             L      u          L     M U      L    y    L         y &	`P-`@`P$` P$PT   QT                                L      u &`P#Qx   hx   @                                    L   L          L      u &	`` `P#Q<   
V<                                L     M&`-Q                                       L     u                L      u          j           L   o   u +`P)` P `  P%T         y                 p   p   >                                 M*         L        Mu L        ` 	P8   }*8                                 L   &`)QH   ZH                                L     L     Q&` P|   |   E   +                                          L   o   y     `
PD`%Q   	lD   d                            L     M4-      L               u                           ` ,	P P   G   k                            j          L   u           o   O      L      L   u    u L    %`+#`P'`@`'PPT         e       h                                             41      L   4            y             8                       L    y    L           u             L    ` P 	` 
`JF` P$`
P `*Q   (*   v                              
   u  u g 8  1  M      L    4      L                         u  @`	VP4@` PT          u       s          h   Qh   3                          )     u                      	`
P 
p  Bgp    
      	                    7               ;                   j      k       k      k      k      k      k      k        y     O	     L	   L
      
     L	      O
          L      u O      `P.` q
P$`/	`-`@` P)VT   qTT   &                                      O      &	`` P    *  
                                       ;   ;   >              :      y         	   	     L        u     4      L                           L   u     L                          .`"@	` `AH`P(	` `AH	`	P(	` `AH`!T     C          ~                                         '           -04  W               P                    L          L            L   L                         L          L            L   L         L   )         L   L         j                   L     u          L   L	   b       L   N         L   L
   4   #    L       &            u (          )     *   M  +         L      L   L   u        0     L    2   X   3   ;     >   )     u    7   j     k       8     8   >   9     L     u       @   =       ,   ?      L   L   L     Mu  E      F     L   u    H     L     u   J   ;     >   )     u    N   j     k       O     O   >    ` 	``/` ` "` P "` )  ( P.	` *`

P(` 	`%(P @I`

P(`   (P `P-`PM`%(P @T        P       C         _            `            T           \          %            $                         	  
                   #      :     y                         L   L   	   (   
     L   L      u          &      :       y                ;                         I      (     :  L       y        y u         L     u $   #   j   	      u k      &      L
      )      L
      *     L   L
   ,        L      /      L      0     L   L   2       L       L   )M   u gL    
  L         L   )M 	     L      ?      L      @     L   L   B          D        D      L      F     L   G        L      I     L   L   K       4   L   L   u     N    N        P        Q     j   R   ;    	  3  3( 
  3(>    
  >    
  >     >    	  >     L      u >   ]    	  3  3( 
  3(_     \   `   ;    
  >    
  >    
  >     >    	  >     L      u >   i    
  i     L         u     4   l   L      m    m        4   n   L      o    o      p    
  p       4   q   L      r    r      s    
  s     j   !   k    "   k   #   k        L$      w      L$      x     L   L$   z   	    L%      }     L%   L&           L'         )      L'   u          L(      u      6        L)   L*        L'      u                  L+              <        L)   L*        L'   ;,   >+   u                 .         L+            L'             -         -     L   L.   3(/   (M   M         -     3(M1         -     3(M         L-                !                                        u   0   L1   L2   L3     u 
    y        j        [        L4   
  u <      )   	  u          L     u               L5           L   L5      $         L   L7   $        L8   L9   :   y      L   L7   J        L   L7       :       y   >;   u .      <    
  3(=   (  L   3(>   (       >          O       L      u O               Z              L     u           j          ;@                                   `   ab         0   L1   LB   LC       u o         3  3(  3(                             LE     :       y       u            M         >-   ;F   >$     >;       y u Q`           LE     :       y ;G   >$     >;       y u Q      M               MQ    N  c             7     )   	  u         L      u   a        LH   	  u       /       LI            u    !    !  J               LK     u    %    %     &        &    LK     u    )    
    )    LL      +    L   LL   -         .    .     /     /    /       0   0         2    L   LM   4          5       6     6  H  7  N         L8   LO        :  P      :  Q   :    	  
       ;       ;    ;  y      =      L    
  :      y >   u        D    L   E  $   F    L8   L9   S   y I  I  j        LT   LU     L   LV     L      P    L   Q  u     L   LW   X       V       W    MX  g   Y      Y      L   2   \    LZ       My   2*  a     a    L   LW   [   L   e    LT   L\     L      i    L   j  u   =   k    LZ     L      n    L   o  y p  o]        L   L^   m   t    L   L_      w    w  #   x    L`   oa   y "   {        
    y |  |    LI            u     0       
         L   Lb     #     	  3  3(
  3(                      L   Lc            L   Lc     L   Lb   "     	  3  3(
  3(     
                      u         >          O       L      u O           ` .	` ` 4PN	` `"@
	`` 	``E  H	``" @,PL	`P`P `
 `
@	`P ` `
 	``/` %` 	` P `.`.`% ,**)*&PH  H(	` 
G  H*`.	`%***)*&PH  H4`E  H6`P(` ` ` ` `
 (` !`



P.` P) ` 4
P /` C
%F@hP=B/#` ` , : , `*	` `OI`P(`  P(	` RP P &P `  &` ` PIP` H" IPEPMS  `.`.` 0P)`D  IY	`D  J[`. `P(` ` f $` %P&` +`  ` 	" #P 7,&&@cP?k ` 	" &&@lPJt`		`@_	Mw	`@y` 'P &P `P)``P  `&`&`P 	`&	` `P-	`&	` .` ` , ` $ ` )/	`  , P$`&`" F  P ` ` P `*` $ P(` `f `
	PD  4` ` ` - P `
 P `K  ` ` `P>   `P `
P)`  	` 	 ` 	` * .  xP 	`.`/` 0P)` H  `%T                Q             .             I                                   6   @	           J
            K
           W
            X
     	   ?   m
  P      A   
       D   ;  e     J   w        N     9     R   }        Y     X                                      
             F     (  a         	                                                           L   L   L        L   L     	  	              y |   	     L   4      L             G        L   L     	  	              y      L        	  	       y   &%` , ` ` 


P.` ` "


PI` 

P%	P         `  d  T     	                             L   L          u        ^             L   L   3(   (M1   
      L     L   L   3   (u    /         L	     L   L   3   (y       L
   o   y 	& `  

P(` , 8  P `  PI`PEPd     	         ]~   \                              j      k    
  
    (         3(M             y  `

 P$P`  Vk2    "                                          L   4      L                      L   L     :   L   L   L       y        y    L   (         L	          L
       L    L   ;    >   u   .        L                 L            L   L   :       y ;   :   L   L       y    L       y >       y y .   )     u {   0      4$   1   L   4   3   L      4    4      6      L   L      8      L   L   L   ;          T   <       L      L   L   u        A     L   B     B      L      D   )      L   u G      H      L      I      I        L   L   L   G   M   :   L   L   L       y       y   U      L   L          L   (   Y      L	      [    L
   \      u     |   ^         L      L   L   u        c     L   d            f      O   g   g      L   !   j       k    L   l   7   m         L	      o    L
   p   O   q      L    /   s      L   L     o      u   w      L      y      L   L   y  |   |      L       ~      L   L          )      u       j      k                    H        4      L                      L!             '  L"             L            L   L#      W      ::     y    L$      u >%   >&          y                u         #*	` ` "	 	 
 .%	HP@` .` ` "	 	&" @	0PI`	P 2&`&`

P(	`@` 

P ` -`"	 	@` $ .P'`*`

P(` `
	`@#` &` ` ` E*
E$7PL+` ` PO-`  `	P  	` ` 	" &PM5	 O0PL8`#T`     "        '           p  J           r                   `  *GP                                4      M            M         L      <   	      L   L        M3(   (   M3(y       L   j     Mw  fL          u  f L         L	   l       lz%`   ` -	P$`AF	`  	P!Q`           .   `  @                                              ;                                )      u       j      k             L   o   y ;      >      >      >      >	      >
    '	`	P` `PDE`%****JLT`     C                      lB  A                2                L       u             L         u     L                 L        L   L   ,   
      L     L   L   u         L	         )     L	   u          .        L
           L	            L   Z      )     L   u         L      "      #     L      %        L      '     L   L   (     L   L     L      ,     L   -     L   u /         L   o   y  /`
P`A=H`
P(`/` `.` `P-#`



P/%`  $`
 
P ` < 
P.`PE=P        ;      5            X    	              %              L       u                          M3   (   3(Mw   	     L   4      L             A        L   4      L     u                          M3   (   3(Q  L   L          3(   (  L	   
   u 3(   (  3(   (   y "       L   o   y )`
P`A1F	` `  +  P ` *`   P0 PI	` PD1P    &                R      $       L       u                   j       k        L   4      L             ?        L   L                y                   :        L   L         L     u        L	   L
   3   (    L	   L
   3   (  L	   L
   3(              L            L     u     @        L       L       L	   L
   u (y &     L       (y     #   *     L       (y -       1  .       3  L	   L      1      1   3(    L   3(    L     y      7     L       9     L     u  ;   ?   <     L       L       L	   L
   u (y C     L       (y     "   G     L       (y J   J   J       J     L   u     r   M     L     u J   P              L               u   R   {R    
*`
P`A)	H` ` ` ` 
P.&` ` -P- `  #`  & `/` $P `PPI`P$` `PI` &"`  ' `P$`/` $P `PPI`P$` `P0"&fP `P-` `
P@)	P           %      0                         ]  '                    $   x                            e         L   L               4         L   L                    &`
  -  Q$  0$                                                       ;          L   4      L             .        L   L            u 	     L   L            u  	` ` #PCF` &P#Qp                   )       $              ;               j      k       k      k      k      k      k   	   k   
   k      k      k	      k
      k      k      k      k        L         )      L   u           	      L      
      
                L                    L   O        L   L   L   F      :  L   L   L       y       y              :      y       Mw  fL   $     u  f L   ;   '   L         U   (     d)   )    )      .` &` 
	P.` 	` `@	` `"	 	@	`.`"	@f  $	`@@`$Tp  @     -   ^       w                           g            J           "  S     >l(            	             $             `   ab             L   L   L       u >           L      L	   u           M         c   k   c 
&`*f $` %	P $	P 	`AJM`!T  x                                                                               I   [                              O         L   L            O         L      u O   &`-` ` P)P  [@p                              @     u             L      u               L      u     L              L   y      L   )ML   u                 L	     L
      u u &`P'	` P `AH`P(	` `AH`P$	` P `AH` PP#T               Q                                                      QH5                               @     u             L      u                 L      u      L     Mu &`P'	` P `CH`P(`P#T               S                        X  2m^  s                     $    )     u          L      u                   L     u M     
        
              L   L              L	   u                       L   L           L	   u             L   L
            L   L              L	   u             &	`	P P !	`)P @` 	`PM
``DH` 	`
PCH`CI` BP QX  H     A         t                            
                              N                                         L   L               L   L               L     u   	      L   >         L   L   $         L   L     u     &	` `$PL`   9P+Q\  |,                                                L   o   y            L   L         	     L   o   y       0        L     L   L   u M         %	``A8'`
PD	` `
PI	``P `%T\                                          &                    
                           L     u      L   L           L      u 	      
         
    
&` `AH`P(` 4P ` P                             &yX                                               L     u      L      u                 L     u      L      u                 L   L   L   o   u    
+` `AH`P(`P`IH`P)`P`JH	` (PJP               "              g                          "I;  /                                             L      u !         L      u 	      
    
     L      u  R         L      u 1        L     L      u u                    L      u           L                   ` 	`C	F`P P `A	F`P P .PP, 	`C	F`
P .`#	V  3H                 !                   j                   u       )     u       j     k            L     u             *        L         j             M    $           L    u M       $           L    u M       $           L    u M               L                 j    !   &	``EH	`!`P,	`	P` 	`P`CH	``@H`,	``-P.	``*P.	``/P.	`` ` T                                                                    v  4               6                 L           j              *        L   L         j         u    j       o      )     u @        L      u           L      u             L   L	   
   &            L     u y      L   L	   
             L   L	      #   &   $         L     u y '     L   L	      &   +         L     u y .   <   .   )     u &   0         L     u y 3      L   o   y    +` OP(`+`K	`	P P P ` &`PP)` M`PP)` %`PP `	P-`PPI`PD`%T        '      1            p   w                  
                     L     u '            L     y )        L   L        3(y 
    ``AF`P-	` P 	` 7PIP   \   J                               L     u +               L     u y     ` P`PP)PT   UqT   *                                                 ` P   U@P   $                          ;   j      k       k   >    `%    )o      
             	                          ;             O       O        L      u O     ;   O    `.`.` P)`/P@   K!@                                L      Q&` P@   3@                                ;   O   &`/P  g    
   	          &      $                    ;                 @                              u     L                             L   ;	     >
     >   u       L   $        L     M         L     ;     >                        -        L   L      y  <        L   n   u        <       L   L      u     L       u   $     L       Q    ` P(` `%)IPH	` `N8
!`%	MP@ `/	` P$	`EJ`P`EJ` +P(`	PO` `$T       9         	            L            W                                                                                                   .   4       
                                       ;            L        u     &        L        u        4#      L   u  L   L               &`P(	`` P-` P T4     9                       y   p                                                  ;          L        u L   o   u  `P
P#Q<   ;<                                  3  3( ` |  {L                                              ;              L         u     (         L         u              j    	     L   u  L   L   o   u L	   o
   u  &`P(	`` P-	``EH`P(P
pP#T|     >                                  <   <                                M   M) &`	!
   Wm   [                  	          L   L   3      L   %            L   L   3(            3(  3( `                
                                      ;            L        u     n        L   L   3  L   $   	        L   L   3(            3(  L     u 3(     L	   L
         3(y   L          u  &`P(	`.` 
  PEH` P$` P#T     E                                                                                                                          u     '               )     u    O       %          u     $       %         u         L&`P(` )P `P(	`	`PM`T     l                   H   +C?H                              L   n      u  	`

P   \                                        ;              L      u O        O        4$      L   4   	   L      
    
         o      O     L	      y  ` P)`.` `
P$P(   +8(                                `   _   U               F                    ;                       	  
                     L            ;   >   O         L   gL     L     L     L     L	     L
     L     L   	  L   
  L     L     L     L     L     L     L     L                        >     O                        O          !        !   !   O          #    3     u    $        %      %   O          '    3     u    (        )      )   O
     	     +      +   O     
     -         -        .      .   O       L      1         1   
     2      2   O          4    3     u '   5        6    3      u 7   O          9    3     u '   :        ;    3      u <   O          >      >   O          @   @   O          C        C   C   O     L   y    	` `)0@	` ` `# `3 ` #P ` #P ` ` ` ` 1P 5P.` 1P 5P.` ` `% `P%P     -   '  l   
l   7                              L   "         L      L   y    &	` `
	P)PH  8                             o              L      L   3   (   L   3(u O            L      L   3   L   3(   (   L	   3(   L   3(u O            L
      L   3   (   L   3(u O
   &`J`		  P)`	'	 
 P)`	&	  VP*PH              h$"   \                           4      L                      O                   ` .	`*	`CF`P#Q  qGd    +             +                                              L   9        L   L           L   L   L         	   ;   
      o        L   y    4      L                     L   L       	    4$      L   4      L	                     L   L	           L   L   L	       
  j   ;
     L   >   o   >   k    ;     L   >   o   >   k         L   o   y    '` `K`P$)` ` , `%//%/@!`PDD`%T     0                                      -               L     L   u         ,               L   L     L   L   u     L   [        L	       :  
    y   
    y   >   u                 L     L   u       L   u  L   u       L     L   u L   u      L	   ,               L   L     L   L   u     :  
    y   
    y   >   u  	.`

P#&`
P(	` '"  H)P=IJ	`


P(`P
P(`
P
P(`
Pi"	 	 	IPCT              1                                                <   P<                                 u  	`
P   >   K                           L   *           L     u u            u     	` PP (Pl                     =      $               L   L     u                       ML   u               u             L  
    	   	  h         	          u   )     u                                -         L   L	   L
        u                s       
   
  "         M     B        L   L         3(   (  3(y          R      )      u    !     L   #      $         u    %     L      u     L      M  u    
   
  Q   +     L   L      L   (0O     L   L      ML   )0O      6     L   O   8      2*        L   "   =      =   =   =    ` fP *`	P(	`P `
-` 3&`P(`P ` 0	P ` ` `-` `  P$`@`
P `PN`
P(	`
P)` ` ` `@	`-` `@"Pl  \     I           Y                                             P  t                  T      $                           ;                           o          L   L      u             j      :      y       L         )      L   u             L                     O	      S
   n   L      Mu '         ML      u (%         ML     L   u        t          ML     u L     L   u L   o   u L      u         ML     u Q0        L        ML   u     u    u     0   7      M      :   )     u <      =     =   )     u    ?        u   @     C   A     L   L         M3(   (   3(y      H     L   0   J     L   o      L   u  u   O      L      M  u      L!   O"   T       '`Jf  P *`*`"	@"` )

P `,`+`P P (
P-` 	`P

P
 P
"P(	` PJ*`	PP,P(`  
P `D;I,`
P`P-`.	` P$	`O1` 	`E5PC2PM7`
P(`@:`$TP  @     O   d                                                         w   /    #p                  5      $             L       L     u              L        3   (   u        M3(     M    L            u       L	   n
   u      L	   n   u     4      L                      .                    L   .    '         L   n      u          L      u     8   "   :     y        y    '   P   '          L   L        3(  y   3  3(   3(-      L   ,   /      L   L     L   u  4      5      S   5       `/`
P`CH`

 PP(`-`*`!
P(#`P(#`P(` / 	`&
P=!	`P)``" @+	` 4P$	` 
FJ` A
P ` `#T                 G               C          (            )                               ^   8   F8                              L   u   
`
P   h2\   V           
       
         L          L   :      y       ML   u  >   u  
`"  PH 2PC
  q           	       4              L   u  L   u     ;        L      u    	         L      u     ML   u  L   u       ML	     ML
   )u                  L      u    A         L   #           L   u  O   !      !             #     L      u &   A   '      L   #   )        L   u  O   ,   =   ,       L      u     L   o   y 1   1   ;      >      >    +`

P
P(`+`
P *`
P(`P
P(`P(	` $P ` `  P ` (P ` ` P &` P(`P@`%):T             Q              3                     X                  +      $                  L      u Mw  fL   u  f L      	       	   L   
            j    L      j           u  f L         L   l                     d      L      u L   u  L	   n
      u      L   u            M             Q           !        Q"           $        Q%         u $   (              
u Q+   +    ` "`P  ` P

P

P(`P(` ` ` ` ` ` `P`%P@
P                  w               .               t   jT   #   	                            ;      o   	%`+`5Tt                             :  +                                  Y       L   F       L   3       L    L   M   	     L   M   0      :       y  L   1A          L      u (          M    6         @    u  u          Q        u  .`(	` `"	 		M`P)` 	`.`	PP(`@`P#T         *      (         8   c#8      	                          o   	`'`   `                                 @    u  u    u  `PPP      m                                     ;              L      u O        O     L      y  ` P)`.`
P$P  7r    
      	                                ;   ;   >              L   L               O     L      
    #     
    ?  
       ;      o	   u >
      o   u >      o   u >      o   u >      o   u >   O     &` ` `)PHPHPHPH	PO&P     C         KdM|   >                              L     :     y       o    %`"@I	`%T         8       ;          H   &H                                  L     u  	` P
   4   H                              L     :     y    >         o    %`" NI	`%T         B       E          H   &H                                  L     u  	` P
   kY|   >                              L     :     y       o    %`"@I	`%T         8       ;          H   &H                                  L     u  	` P
   A"   I   	                              L     :      y       o   	%`"@I	`%T         :       F          l   ]9l   7                               L       L               u  	`  P   P|   >                              L     :     y       o    %`"@I	`%T         8       ;          H   &H                                  L     u  	` P
\   u\   ,                             L     L   u  L   u   Q&` P
P(Pl   Rl   5                             L     L   u  L   u   #    u Q&` P
P	 P%P  e_X                 ,      $                                  ;               L      L   u     L    b        ML      u  @        ML      u         L	   o
   u              L   o   u     j     Mk      L     u Mw  fL           u  f L      #   L   l%    L      L   u Q)     L   o      u      #*`
P(	` !P P !P "&`P(`
P 
PK`EDPH`$T       X   z                                  W  .   @   (t,@                              L      u   `P@   (t,@                              L      u   `P  /u                  &      $     ;    u gL      L        L      M                     4*      L   4   	      L   M                ;	          L
   X        L   D            L
   *         L                       L      M    :      y           y       y u   2              L   L     y "     *   "      L   L         3(y &      @`P ` &`(+` ` ` %"  @
/P@+` PJ	`D? 	` $PI`#T                 G            V   2          %                                                  V   7  p   z
p   =                  	         L    M(        L    U  L   2+O   	    `-`-`0P                   &                 7                     ;                     O       O       O       L   O       O        L      u O	     j    O
       L         
   O     O       L   "        L            O       L   "        L         ^   O     ;   O     j    O     L   4B   "   L   4   $   $   $       L     y    &    &      `P.`/`/`/` `/` P)` ` `,` ` ` ` ` 
	P V<  Z(  z                1                    ;      ;      ;      ;        L   o   y    L	      u L
   $         L	      u L
      h        L   L   ;      >      L	      u L
   >   ;   >   j    >    >   y     ;      L	      u >      L	      u >      L	      u >      L	      u >    +%`+`+`+`+`
PD	`P #P ` %	*	P-	*	*	HPI!`%P(P(P(PH'T<        [      w            N4   R   	                                 L   o   y                Q   		%`'`PD`` P         C   (  ,Wok                  $           3   (  3(     L   '        L   L       u    !   	     L      Q%       L      M              L      M<             M           Q           L      Q                M           Q          M           Q          M   #       Q$    &` *` 0P ` ` ` `` ` ` `` `` ``@P(           X  H                 "                        L      u     M     M     -         L              y         	    	   :   
      L   L          ;   >	   y       L
                      Q                     L
     Q   ;         L   L   o   y    L         y       L   L   o   u O    +` P(`,`,	`` P)	` ` %	FPI
` 	` ` `+` PD#` P$` P*PX              7  	                                L   j       k        y B        y   $         L   L     y       L       
      L               L      L   u L   o	   y    O      L   L
   )         L      L   y          L   y     )`	


P$`P$`` P)`  	`
P
PD	`,` `
P `PIP          	                                  M           ;   Q     L      M      L            L   o   y    	&` ` ` ` `PJ	P      	   x   h   Th   8                                M  M           M  Q    ` ` P0   @0   
                           L    `	  Wd]\                  /      $                                                           L                     L            ;   u      L     L   "d        L   L   ;	     >
     >     >     >     >     >   y       L   2*O   o        L     ML     L   u       L      !             u        #     L      &   2   '     L   o   u L      y    ,         y -   '   -              y .    .              u  A+	` `PC+H	`
 ` %	*	*	*	*	*	JPD`A+H` `K` 
P(	` '`P(` `P
+P `P@%+	`	PJ(`A+H*`
P#T                              >                        <             ^             }                        1           	               L   2+O     L   L    p           L   L   u       L      L      L      L	      L
      L      L   y      .                    L      %          o       y             y  ` ` &` P(	`
	
						PJ`  	`E	JPD
	`AF`	P$P     .   f      nN   \           	                 L   L                     (    ,    y  ` 




P$	PD   t|D                                     u  
`Pd  {4                                                   ;                L   C         L   L      y            u  	   	   )      u '         L   L      u       )     u       j     k            L	            u     L
   L   4        L   L            y          L
   L   o   y  0&	` ` P$` PHH	`	P` 2P-	`	P` `	P(	` ` `.`AH` PEPd     R   E                    w         D   D                               L     y  `P$P\   d\   $                             L      ;    y &`P$P`   .l`   *                             L      ;   >    y &`%&C
PDP   [            	                                                    L      u       M      M     L            o   y  +` P(`,`,`

PE	P      C   `   T  ,T                             W        L   L       3   (      3(   (      3(   (  y 	               Q        L   L       3   (      3(   (      3( y      L          y  ``     P)` `    P)`
P$P@       !   
          H      $                                           ;                o           L   4$      L   4      L      	    	   O   
     L   4-      L   4      L     u              B        L   L        3(	   (  3(
   (   y       '                                   L   4       L      !    !     "       :      y   >       L   L   L     L   u     L     .   	   	    L   0   0                 u 	  '   1               u 	  2   	     3   	  L      6   2   7   	  L   o   u L      y    <       	  y =   '   =    	  	      	  y >   ,   >                    y ?   ?         A      MC      D    D     L   L      M      y  	` , *P `  P$`A#F	` &`A#F	` *`"	 	N` 	P(` &` `P `PM` `P
&P `
P@+`P0 	`PO!	`  `A#F"` P$P@  0            I            5                 I     $   q$                                D   RD                                     u  
`
P  X                   5        ;   >   >   j      k    >   j      k    >   j      k    >   >	   >
   >      >   >   >      >      >      >      >   >   >   >      >   >   >   >   >   >    >!   >"   >#   >$   >%   >&   >'   >(   o)   >*   ;+   >,   o-   >.   /   >0   1   >2   3   >4   5   >6   7   >8   9   >:   3   >;   ><   >=   >>   >?    `%&&   &&&*&&****&&&*&&&&&&&&&&&&&J.%&********(K;&    !                 !         ;        M           M      )     Mu    	        MO      )     Mu            MO        M           M      V           M        M         L      u L	   o
   y !       
%`+	` ` 	`	P` 	`	P` 	`  %` `P
PJ`%T                G                    H   <H                                          MQ 	` P(   +8(                                `  \R%  k                 $        )     L   u %        j     L   k    O       )     L   u %   	     j     L   k    O       )     L   u %        j     L   k    O        L   46      L   4               u           4          L   L   j      k    u O        L   	      "       L   O
   $      `	P` `	P` `	P` `  P ` 5PN` ,` `Q$   Up2$                                  - li   M   	             	                 L      L      u u       L   o   y 	
&`PP(`P5P      	   C   x   Fx   B                              M   ,                ML      u Q    	` ` PJP  dK  f                               7            ;                           4      u O      ;   O        O      ;   j    >   O         y    -         L	            L
      `         L   L   1         L         y              o   y        `P ` P)` ` `+@`P$	`   ` 	`
	P$	`FK`5APIWX   _,zX   &                             L               y  	`

	
P$P    
     
                                 ;                            O                 ;            L      	      L   
   |      )      L   u "            L   O   C         L   L      u             L   MO      *   u      :  	    y   L
   	    y 4      u 	    y O
     L
   :  L   	    y   L
   L   	    y O      L   #   0     L
      L   O   3      L   #   6     L
      L   O   9   o       L
   L   /  =         	    L   L   @   @     L        L   L   u   L
   y %   F     L     L
   y I        L   L   #   L     L   L        N   =    N   "    L
          7    L
   L     L
      O     L         O       L   O       O         ;     L
   L   >     L
   L   >      O      L
   L   L!   .   g     L
   L   L!     L   L!   m   	  	  $   n     L   L"   #   y q     N   r     L
   L   L!   .   w     L
   L   L!     L   L!   }      ~          u O     L   L   ,        L   L       L
   y      L
   L     L   L!   L$     L   u O!        1    L
      O%     ;&     L'   L$     u >'   O(            L   L)   u   L       L
      O*     L*   L+   ,   o-   y   L   L.   t             L   L.   u O.     L.   L   ;        L.   L       L
   L/     L
   y      L   L0   \             L   L0   u O0     L0   L   #        L0   L     y      -    L     L
      O1     L1   L+   ,   o2   y   L   L3   L4   o5   y        L
   L   L!   O!           .         L
   L6   6        L   L.           L
   L7                L   L   L9     L
   L6   u     L:            M;               L
     MO7           L   L.           L
   L7      $        L   L<   =   y    j   >   k    ?   k   @   k   A   k       L4   oB   y j   C   k    D   k   E   k   F   k       L4   oG   y 5   u     oH       L
   L          L
   LI             y     	  J      y        `,	` `*`O	` `		P-	` ` P/	`@`.`'  P@`, @	`	-`@	`	-`@!`J"	`  ` 	`P*
P 	`
P9(&` 	` 	`O.`(`P)`/`/` `.`
&%	 	@4PI8)` K `.	` PI<` L 	`	"P)` ` 
P)	` <	PNA`
"P)`)	 1PNE`
#P+	P)` PDI` 	`	)P)` ` 
PIM` 	`	#P)` ` PIQ`!
P)` PDU` PJY` 	`` 	`  # &` -P(` (`@_	` # ` PIb` `PDf` `PDm`/`J{	`  ` `P `%T     C   	     i  %      8   %             
         x   R{x   9                                                        ``AF`%`PCF`#Q   Pd   u                           L   j     k     Mw  fL          u  f L      	   L   l    z%	` 
	 P"P         7   .      Pd   u                           L   j     k     Mw  fL          u  f L      	   L   l    z%	` 
	 P"P         7   .   `   $`   +                           L           L     y     ` `
P)PD   D      	                               o   Q)` P   z}                                L      M  { b      Mw  fL   j    	       u  f L         L   l             z`   P         B   .   D   TD      	                               o   Q)`@P   
                                 L      M  { b      Mw  fL   j    	       u  f L         L   l             z  %	`   P"	`%Q         B   .     uu                              o        L           L      /            L   L     u u 
     L     L   L	      y  &`J
`  ` PPCH`P%P                c          d  Obd                            O     L           L      $        L   L      y 	     O     L   L   .        L   L	   
     L   y      L   
     L   y       L    y         y  	`,`  ` P)	`,` ` 
P)	` 
P$	` P$	`	P$P  _"T    
      	       7                           .                 )      u                  L                            L   L      
     L   L                4      L   u               =        L   L	   "        L   L	   L
                u     j       o        W          L   L   L     L   L   u     L   o   y    '         y (     L   L	   46   +   L   4   -      -   o   y    /    /     L   L   L        L   L   o   y    6       y 7    +`*`	P 	`  `/	` A%` P  =`PCI`+`K`
&` -P(	`P 	`PI`  P ` $P? `PJP     ?   _                 l            m             H         ]c   o                 
                                      L   L   L     u       L   o   y  	&``AH` `AH` /P(	`PEP          n                     2             \   V                                              L     u          L     y     ` `A	F` P`P)	P@   :@                                     u  `P@   :@                                     u  `P   ?o   p                           +        L           L      $        L     L   y 
          y  ` )`
P)	`P$P  h                                  5   u                      |t                         L                  L   L    
           .          L   L   L      o   y    %`/	`/`)` K	`/`)` K
	`` 	`` 	`` ` &PD`%T                         \   [v2\   #                               L   y       y  ` 	P$`	P$Px  x                 2                                L                       L         
      L     O        L      9        L   &        L	           L
               L     O        L               L     O        L               L     O   !     L         $   '  L     y &     L         )      L     O   +     L      &   .      L   L   L     y 2      &	`	`P)	` `P)	` `@	` `@		` `@	` `@	` `PI	` `@	` ` PI`$Q  9W                 ,     $              L                j      k       k   L     u     
    
       
        L   L              L     M  j      k       k   L     u        E         L   L	     u            O
               2*  :      L
   D         L   L     u !   $      L   L	     u '   .   (        O
      L   L     y ,   &	` `AF	` P `AF
	`f &` ` P `+` 'P-	`.	`@2`@	` 1P 9P `-` PIP       o                                  &               {        [                 /                           O   5   u       L        y o      o      o        :   	     L   L	            L   L	   L
      1            L   L	   L   u  y         9        L   L	           L   L	   L
              L   L	   L   L    7   $     L   L	   L   u  L      y (   *     L   L	   L      y .      .         y /       +` `/` P$`K
`K`J(	` * ` PP.` ` 	` P
P 	` &P00 `PI3`%T                          (]   V                  	          O       L   L   L     u O     O     L     y  `.` @P)`(`P$P|  Sfu|                                   L     v              y   L   L    y   O     L       y   L   L       y            O            L   o	   y              o
   y     `-`
 `P$` P$`(` P$` #P0	 	`M` P$`
`	P)P   'C	                                L     { b      Mw  fL   j           u  f L         L   l             z`
  P	         <   .      'C	                                L     { b      Mw  fL   j           u  f L         L   l             z`
  P	         <   .     ?k                  *              )                L   L            j         )     u    
        
             M        L   L      u          X        L   L   L   )     u       j     k               u                  L                 y      L	   L   $        L	   L
      y !     L   L   46   $   L   4   &      &      y    '    '   '     L      o   y  
+`  )`.`	P ` 'P Y	P  P.`/` `PI` ` P)	` 4P@`PEP          P   EP                                         y  	`
P$P   =-                                    o      )     u            O              O          O        O       %`K!	`	P-` `@&`.` `%T         s                   L0E    	      	       <                       M        L   L   j     k      k   L    u u    &   	   :      y             L             L      O         L             L      O         L             L      O      L	   
   N            L	   *                  L	      O	         L   L      #      #             L	      %      L     u (   &   )     L   o   u       ,     I   .   (     :  L       y       y u   5      L	   &   7      L	   3   3(  3(   :     :      :     L         u '` 	` 2 PP 	`"@	` ` ` ` ` `&` P 	`
P0 ``" @.PL	` @`P#T                          b   v                           I      (     :  L       y       y u   	         L   3      3(  3( ``" @,PL` 
 %	Q   1            	                      L   4      L     { b      Mw  fL   j    
       u  f L         L   l             z          +` %  P Q         Q   .      2            	                      L   4      L     { b      Mw  fL   j    
       u  f L         L   l             z          +` "  P Q         Q   .   D   |!D                                L     O   &` P  @    
             B                           ;                   L   2         L   L         L   y       L            L   L      2         L   L   	      L   y      L
   ,         L            L   M        L            L   L                 L      L   L   )M    L   u        &   &   o       L   K   )       L        u        -     -   -      L        u    0   0      L   L   L   5   5      L   L      8      L   L   ;      <   <           u +   >        @           u A      B   B     	` ` D
P$`AH	`  ` O
P$`AH	` ` ` 	`P `AH`J	` &`P(``DO	`P`AH	` E '`AH	`P 	P `AH`!T     :                                                   A                                  5                                                   }   d                             L   L   L     3   ( 3(M      $                       
&` (
+` T          c       a          p  `N@                                   5   u       L   L   :                 y        L   u  	   )     u       j     k           L   o   y   L   o	   y     %`/	` `
`/`PCH	`	P` `
PD
`PD`%Tp               l                              K                  
         L   L   L     u '        L   L   L     y 
    ` P` P)Pp   SJp   7                               L   y               y     ` 	P$`
`	P)P  X  !                                  5   u     )     u       j     k           L   L         j            L   o   u       L   :                 y        L   u       L      L	      u O     L
   o   y     +`/	`	P` ` `
P(	` `
`/`PCH	` (P)`PD`%T                                           F                               L     u '        L   L   L     u     	` P @Pp   SJp   7                               L   y               y     ` 	P$`
`	P)P<  ij          
       1      $         {         L   _         L   4      L                       L   M   
      L                              L	                    L
      ^          L
   u              L              L                       j>      k       k      k      k      k      k      k      k      k      k	      k
      k      k      k      k      k      k      k       k   !   k   "   k   #   k   $   k   %   k   &   k   '   k   (   k   )   k   *   k   +   k   ,   k   -   k   .   k    /   k!   0   k"   1   k#   2   k$   3   k%   4   k&   5   k'   6   k(   7   k)   8   k*   9   k+   :   k,   ;   k-   <   k.   =   k/   >   k0   ?   k1   @   k2   A   k3   B   k4   C   k5   D   k6   E   k7   F   k8   G   k9   H   k:   I   k;   J   k<   K   k=        LL   4      LM             !      "  *   u            LN   u  LO   P   u     %   Q   %     LO     LR     u u  )   +     LN   u  LO   S   u  0      1         1   Q   1   *	`` 	``EH	'`(` &`P(` `I@	@` ` 1VP-	`
PP`EH`&PP @PP T<  ,                                           T         @           A            B           \             g                                          u   
                                  ;                                   L   O      &`
	(` `$T      3   A       r            51l  e  
             R                        ;                 .                   L                S      :  L       y        y ;   >       y                  L            L	      -            L
   L      u O
      j      k       k      k       L   o   y    :  L       y O      L   ;      L   L      u >   O        +        L     L   L   u L   o   ;   u      7         O      L      L   O   9      L   +   ;      L   1       O   >      -     L        O      L   L    !   o"   y    L#       y    L     O      L   L$   L   ;%      L   L      u >   O         `.	``/`"  &	@
`
)	`	  ` "PN` `PD`'@`/ 2PN	`&`P
E$
E7PH%` P)`@(	` ` /P.`"
P)` PD-`P$` `  2PN2`%T     X          x           b         D   ktoD                                        MQ ` P   Ae                                          :  L   L      M    y Q         L         Mu L   o         Mu Q    	`,@	` P
E	K(PE
	`%Q\   Q-H\   -                            :      M M    y Q   `(@`#	Q   'v   z                               L   j     k     Mw  fL          u  f L      	   L   l    z%` 	 P"P         <   .      >   S                           ;      L   >      L   >      L   >      L   >      L   >   &`%....NQ3  `  `  `  `a    p      `w     `  `     p  `      .  	  `
  `  `  .      `   @!  {    *     @  @  @  k    `  `!    k      .      `  `!    k      `  `  k  !  {    *     `  `  `  `z  A   *    `    P"    `  `    P  p  `,  K  -  .    `  `-     +  .    ,  Z   2        `     `?  ;    `  `w   9    p  /  (  :    p<  |  )    !  `  >  "  `.  #  `!  {    *     $  `  %  `w   &  `        '  `  _  -  (  `I  G  )  `I  J  *  `I     +  `K     -  `  @P  .  `  @Q  R  F  O  S  /  `T  G  w   0  `T  J  w   1  `T     w   2  `T  J  V  3  `S  Q     F  4  `F  	  @Q  :  D   O  5  `O  Q  F  6  `
  @^  8  `9  `^  K       7  `        (  p:  `^  Z   =  `  A  j     >  `@  `  A  j     A  `   ;  `^  <  `$     ~      +  p*  ?  `,  pB  `  @i   j    @  O  7  .  k  C  `O       D  `E  `O     n  F  `  @G  `7  O  k    .    $  q    A  j         <  H  `  @s  I  `7  O  <       .  l    d  t  J  `  @s  K  `$  q  r    @d  t  L  `  @s  y  M  `  .    l      @&  {  |  D   d  t  N  `~    m  d    O  `o  P  `O  j  o  Q  `  T  `!       R  `S  `  !        9  pU  `  V  `  8  X  `    W  `   =  p[  `    I    |  Y  `Z  `!  Y  ?  p   I    |  \  `]  `<  7  .  ^  ``  `  @              O  7  .  Y    F  a  `   b  `  @  @  c  `D         d  `e  `6  O  :  7   j        f  `          @
      2  <    @q  `r  `O        d    u  `  s  `t  `      O             I  pg  `h  `D   O      @w   $  q  *    7      
    6  :  p             @                @  Z  X  \        F             @      !  {           i  `  F  J           j  `  @k  `  *   l  `     @!  @<    m  `      n  `G      o  `            p  `       G  p       H  p    {  `  F  J        A  j     v  `w  `  {  O      D   p           "  @    x  `  P  #  @  y  `          z  `    K  p                  `  `       `    F   O                ` _     o    `  -     F  J    <  	 
      O  p~  `  `    
    O   <   F         w         p          N  p|  `$  @}  `   M  p%  @            `O    w     `&  @  o      `'  @  `        p       7  6            F     O    D     `A  j       `  `    `!  {    *   >      `O   Y    F    `  `  -         x   <    `  `  -       `  -    `Q  !   `O  "   #   `O  % & '         `  ` O   $   `  -  >      `  ` $  O      \  p  `  `   Z  pO   [  p      `  `$  q  V        `$   F  J  1   `     `  `  O    _  p  -  _  % &  2      `  p  `f  h    `*  @f  h  7   `+  @  O  Y    F  ,  @9   `;   `-  @9   `.  @  `?    @ &  |  /  @>   9 Q  Y  0  @  `  `F     D     P   =   `1  @  `= ? 6 7     `  `2  @  :  i  p  `  `O  M   w     `3  @  `= ? 6 7 I k  p:  l  p  `4  @  `= O  M   w   5 F  J  N   ?   `.    `  `    PS   `  `5  @Y    F  O    U q  pP    `6  @  `  7  @V    X Q  Y   Z [ \ ] ^ _ ` a b c d e f ,  w   -  g )  h   `O  P    `    +  g    `  `u  pk Q  l   m ] \   ^ n `   `  `  [   `O  7  k  d U D   q   2  r <    `  `V      `u      `r   `w   !  {    *   F  J  z { X v       c   `  `O      8  @w  ph s   9  @m u x  pv :  @k y  p   z  p  `  `b     +   {        P  P      P"  &  {  D     `F  J     Q    `r   `U p  D   r q   `;  @  `|  p       `D           P   }    [     :  }  p9  %  *   r F  J    w      ~  pk     `  `  :  A  j     <  r   	  Pw           o    `  `  r <  @  (    `  >    G   :       `;       p=  @    `  `q  D   &  |    `  `>  @  p  `  `  p  `?  @Y   F  O  P    `U   `  `Q  X  D     p  `U   `  `Q  X  D   G       p  `U   `  `Q  S  D     p  `U   M     `  `Q  Z  D     p  `U   `  `Q  V  D     p  `@  @A  @    `[ ,   B  @  p    pG     p   p   p    `   r   `   r   `  )    `  )    `  `     `  ` q D  @
  p  D     `F  J     `C  @  `  [     (  )       p  `     pn  A  j     <     p  `r     `E  @      O  Y    F       F  @   P   ` `|    ~     ` `     p  `  `G  @H  @I  @J  @     p!          K  @r   L  @     M  @   
 ` `	 `P  @        p `       j   !          p    `j    ` `  |  d    w  N  @y    O  @      p 9    p `  *    `     `2    p           p ` `  `  Q  @     R  @p         p   `      p1    ` `  `S  @ ` F  J           r       p ` T  @ ` U  @  `F  J     G     `w    `  |      p `  ` `V  @  p     F  J      w    Y   `D        `      p1   ! ` r  & `# `$ `X  @     % `!          p' `" `W  @S   i   j  ?     '    %   .  7  :  6  _                  s                     p  Y  @V   pU e Q  f   ,  [ -  ] g ^ )  ` b c      ( `         <       ) `, `   * `+ `!           p/ `P  . `Z  @O  [  @  F  \  @     P     p2 `4 `d  A  j     5 `d  A  j     6 `P  9 ` A  j     8 `  p; ` A  j     : `  p> `   F  J   O   G   d    < `= `  p  t     O  p  0 `]  @1 ` ^  @j     i  D   O    7    6      p 3 ` F  P   v         _  @  M    U U      `  @       *    p        p      p  p  7 `    ? J   o  ~        pr  u  w  }    p  p  D `      B `C `             pF `G `H `     ? `@ `   O  v   A `         pE `             p  p  %    pK `  I `J ` O          pL `,        F  G  J                 M `   ?   N `  O `     R `            T `t  A  j     U `t  A  j     S `     d   F  G      p  pX `V `W `        (            pP `Q ` d     p  p  p           ] `O  D    [ `\ `O    <   D   p      w   7  .  $  q  :    pt  Y `Z `  pp      ^ `    A  j     _ `    A  j     ` `O  j  c `d `      |  a `a  @b ` F  J  
     p   O          p e `~       v   h `O       i `  f `g `O   a         p   pl `      $ m `  j `k `O   9    p  a    <      pn `o `        p `Q  W   q `\   r `          ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; N  \ < = > ? @   A B C   D E F  G H I J _ K L         M N  O s `b  @t `P w `z `D   y `   D   !        p{ `d  A  j     u `c  @v `S O  D   d  @ S  Q  F  [             pe  @    x `!          pf  @         *    pP    g  @| `h  @O           `  p  p  p  p   P  p  p	  p
  p  p  p  p  p  p  @  p  p{  A     p/    @  p  p  p  @F      pG    pJ    p     pI  ,  `  p  pP    p   p!  p"  pU  #  pT  $  pY  %  p[  &  p'  p )  pc  *  pd  -  p.  pl  /  pm  0  po  1  pr  2  pu  3  pw  4  p}  5  p~  6  p  7  p  8  p  :  p    @  @  ;  p  <  p  N    >  p@  p  @A  p_  `B  pC  p  D  p  E  p  F  p  J  p  L  p  P  p  Q  pR  p  S  p  T  pU  p V  p W  p X  p$ Y  p( ]  p  ^  p  (  @)  @a  p5 b  p6 c  pd  p: e  p< f  p= g  pG h  pH j  p  m  p  n  po  pp  pr  ps  p  t  ph v  p  {  p    p  p  p  p  p  p     p   pU   p  p  p   p   p    p   p%   p   p   p    p  p  p  p- `  p  p  p   p   p   p   p  p   pt    p  p	   p   p   p   p   pP   pR   pXV                              !
             !
       Z     !             !
             !
 
      [     !       	      !
             !
             !
 $   	         !
 -            !
 3            !
 ;            !
 =            !
 B            !
 G             !
 F      \     ! K      +      #	 P      /      "  a      5      !
 \      ]     ! ^      ^     ! r      ?      !
       C      !
       G      "        J      "               "        I      "        M      #       P      "        G      "        J      "               "        U      "        T      "        Y      "        [      "        ]      #	            "        _     !       c      "        d      "        `     !       `     !       h      #	       l      "        m      "        o      "       r      "    
   u      "  &     w      "  7     }      "  =     ~      "  ?           "  C           "  I           "  E     a     ! P           "  R           "  X           "  U     b     ! a  	           [     c     ! j             o           !
 p           #            "    	         "             "    d         "             !
      e     !      f     ! %  '         "    
   g     !            "  r     h     ! b     i     ! L     j     !            "       o      "             "    
         "            #	           "            "            "    	   $     "    	   (     "       k     !   	   k     !      l     ! 
           "             "       0     !
      n     ! ,     5     !
 /     6     !
 4  	   8     #	 =     :     "  ?     <     "  B     =     "  \     G     "  e     H     "  d     o     ! p           "  j     p     ! k     p     ! {           "       O     !
      P     !
   
   T     #	      q     !      P      "             "       h     "       i     !
            "       p     !
      v     !
      v     !
      u     ! -  #         "       }     !
 %     w     ! '     x     ! `          !
 P     y     ! }          !
 v     z     !           !
      {     !           #	      P      "       |     !      }     !      ~     !           !           !           !           !           !           !           !             "            "       U     "            !           !           !           !
           #	            "            !           ! N          "  @          ! 9          ! 8          ! L          ! t           "  c          !
 `          ! s          !           "            !      %     "            "            "    	        !            "            !
           !   @          !
            !
           !      U     !
            !
 +          !
 /          !
 ,          ! 8          # 6          ! y  K   P      "  G          !
 H          ! M          ! R          ! Y          ! T          ! `          ! [          ! o  
   %     !
 b          !
           "            !
           !           !           !           !   	        "            !           "            "  D           "             !
 *     j       !
            ! %          ! 6          !
 5          ! h          "  V          !
 R          ! o     t      "  u           "  {     	     "            "  ~          !
   
        "            !           !           "            !           !   T        "       P     "  )  &   R     "            !           !           ! $          ! O           "  H      r9     r9                 ;   [   ;   [                  i   +  i   +                                             >    >                                                                  m    m                                                                 r    r  .                         D               0    0    L               	  	  	  	  U               	    	    \                       l                       u                       w   '           0      L  |                J    J                                       \    \       &              5    5     L              P    P                 g    g                                                                I    I                 S    M       	                                                      B                      B "  b    b               B j    e                 B                                  
             s    s     	           {    v                  ^    I                                                                  u    u               |    x                                                            
   N!    .  "             ^!  !  Q!  !  0             !  I"  !  I"  5             W"  &  L"  &  ;             +&  ,(   &  ,(  V             ;(  m)  /(  m)  e             )  ,  p)  ,  o             (,  ,  ,  ,               ,  -  ,  -               3-  -  "-  -               -  -  -  -               -  .  -  .                c.  .  c.  .               .  .  .  .    	            .  8/  .  8/               B/  0  </  0    	            /  /  /  /                W0  1  C0  1                 0  t1  0  t1                1  `2  1  `2                2  2  2  2              
 .3  4  2  E|               4  4  4  4               4  >6  4  >6    	           O6  	;  A6  	;              ;  ~^  ;  ~^                V  Y  V  Y               Y  [  Y  [                 [  [   [  [                ^  h  ^  h              @ d  e  d  e    A           h  >v  h  >v    
            h  u  h  u               k  u  k  u  
              Mn  u  Mn  u               Nv  v  Av  v  E             v  w  v  w  H             w  {  w  {  L              &{  C|  {  C|  c             o|  }  Z|    n             &}  F~  }  F~  s             `~    I~    |                G    G               Y  \  J  \               t  <  _  <                  }    }                                                1           O    ?                                       s  @  s  @                7    7                    E    E                Z    Z                    z    v                   }      
                                           
           !                       _    _                <  Y  <  Y    0           m    b                  6    6      9                                 +  t  "  t                        &                      .             =    (    0                      3  6           	        6                7    7  \              E    :    _               g  /  g  /  `                     k                      p                                    M    M                                                             "  t  "  t                          R              *    *    #              R    R                -    -                 p  M  p  M                  J    J    
           n    n                    v    v       (             ?    K  "             F    B    '              H    H    -                      1                      3                      8                a    a  :              :  X  :  X  >             {  /  {  /  @                &    &  D              A    A    F                      J               -    -  N             9    0    Q               I    I  T  	            a  {  a  {  V  j                    W  +            L  )  L  )  Z  #            a    a    u            
         |                                  L  ,  L  ,                                       E    E    	                                D  Q  D  Q    '              9    9                 1  ?  1  ?    $           L     H                                           F    F                 I  g  I  g               1    #                  d    d                                      
          	             +    +    
               %     %  #  0           9    .    )                      )  W             q    q    ?                E    E  N               [    [    o  %                    v  $            5  E  5  E  ~              ^  7  ^  7                D  M  D  M                i  7  i  7                  3    3               t  J  D  	6                 ;    ;                Q  N M  N                 w    w    !          @ {    {      "          @                         O    O    %            #  #             @                   &  &             @                   X  X  !               u & u & "             ^ T Q T 5                A	   A	 <               7	  7	 @              	 	 	 	 G              >
 N
 >
 N
 K  '            
 ! 
 ! L  D           f @ W @ T               %  % a  5           F  C  g              S  S              d  V                                                  @ I e I e             @       #                                                                  H c H c                T  T             B   Q    Q              B Z    T      	                                  %   %               m# $ m# $              % t' % t'               & & & &               ' Y' ' Y'              ' ) w' ) #              .( ( .( ( '  !            6) ) 6) ) -             ) - ) - 3              - . - . C             . >5 . >5 H              0 0 0 0 W             1 2 1 2 a  >            @2 2 @2 2 e  /          @ 4 P4 4 P4 r             G5 6 A5 6 |  	           m                            Y     Y      P     P                 P      P                                                                t      t                    	     	                                                  ]   ^       5N|      i]di]PIk>   q    O^partitionKey=%28http%2Clocalhost%29,:http://localhost:5173/node_modules/.vite/deps/chunk-MOZ4RPRG.js?v=e7284969 strongly-framed 1 request-method GET response-head HTTP/1.1 200 OK
Vary: Origin
Content-Type: text/javascript
Cache-Control: max-age=31536000,immutable
Etag: W/"13972-lUz+SJ2ybhpI6s8lGh8ht8Jje9o"
Date: Wed, 07 Jan 2026 02:21:13 GMT
Content-Length: 80242
 original-response-headers Vary: Origin
Content-Type: text/javascript
Cache-Control: max-age=31536000,immutable
Etag: W/"13972-lUz+SJ2ybhpI6s8lGh8ht8Jje9o"
Date: Wed, 07 Jan 2026 02:21:13 GMT
Connection: keep-alive
Keep-Alive: timeout=5
Content-Length: 80242
 ctid 2 net-response-time-onstart 8 net-response-time-onstop 8 alt-data 1;80242,javascript/moz-module-bytecode-20251217233610-8l alt-data-from-child 1  