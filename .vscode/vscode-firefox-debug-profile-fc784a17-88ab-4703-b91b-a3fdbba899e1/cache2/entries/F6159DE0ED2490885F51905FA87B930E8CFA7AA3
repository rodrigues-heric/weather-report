import {
  createContextScope,
  useCallbackRef,
  useLayoutEffect2
} from "/node_modules/.vite/deps/chunk-XH2FCAM7.js?v=e7284969";
import {
  composeRefs,
  useComposedRefs
} from "/node_modules/.vite/deps/chunk-MS2BCRFE.js?v=e7284969";
import {
  require_react_dom
} from "/node_modules/.vite/deps/chunk-I3XRBTSS.js?v=e7284969";
import {
  require_jsx_runtime
} from "/node_modules/.vite/deps/chunk-T7ATK2ZT.js?v=e7284969";
import {
  require_react
} from "/node_modules/.vite/deps/chunk-YX2XZWS3.js?v=e7284969";
import {
  __toESM
} from "/node_modules/.vite/deps/chunk-G3PMV62Z.js?v=e7284969";

// node_modules/@radix-ui/react-popper/dist/index.mjs
var React8 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react.useLayoutEffect : noop;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot22 = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props2);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable22;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot3 = createSlot(`Primitive.${node}`);
  const Node2 = React3.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot3 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime2.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow = React4.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime3.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime3.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root = Arrow;

// node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-slot/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function createSlot2(ownerName) {
  const SlotClone = createSlotClone2(ownerName);
  const Slot22 = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React5.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React5.Children.count(newElement) > 1) return React5.Children.only(null);
          return React5.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime4.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React5.isValidElement(newElement) ? React5.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime4.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot2 = createSlot2("Slot");
function createSlotClone2(ownerName) {
  const SlotClone = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React5.isValidElement(children)) {
      const childrenRef = getElementRef2(children);
      const props2 = mergeProps2(slotProps, children.props);
      if (children.type !== React5.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React5.cloneElement(children, props2);
    }
    return React5.Children.count(children) > 1 ? React5.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER2 = Symbol("radix.slottable");
function createSlottable2(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER2;
  return Slottable22;
}
var Slottable2 = createSlottable2("Slottable");
function isSlottable2(child) {
  return React5.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var NODES2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive2 = NODES2.reduce((primitive, node) => {
  const Slot3 = createSlot2(`Primitive.${node}`);
  const Node2 = React6.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot3 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime5.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});

// node_modules/@radix-ui/react-use-size/dist/index.mjs
var React7 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React7.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React8.useState(null);
  return (0, import_jsx_runtime6.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React8.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React8.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = React8.useRef(null);
    React8.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : (0, import_jsx_runtime6.jsx)(Primitive2.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React8.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React8.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React8.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = React8.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime6.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime6.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime6.jsx)(
              Primitive2.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React8.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime6.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime6.jsx)(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

export {
  createPopperScope,
  Root2,
  Anchor,
  Content,
  Arrow2 as Arrow
};
//# sourceMappingURL=chunk-JPVZI2IN.js.map
        < x      20251217233610-8l g&J   http://localhost:5173/node_modules/.vite/deps/chunk-JPVZI2IN.js?v=e7284969   c h u n k - J P V Z I 2 I N . j s . m a p       I import {
  createContextScope,
  useCallbackRef,
  useLayoutEffect2
} from "/node_modules/.vite/deps/chunk-XH2FCAM7.js?v=e7284969";
import {
  composeRefs,
  useComposedRefs
} from "/node_modules/.vite/deps/chunk-MS2BCRFE.js?v=e7284969";
import {
  require_react_dom
} from "/node_modules/.vite/deps/chunk-I3XRBTSS.js?v=e7284969";
import {
  require_jsx_runtime
} from "/node_modules/.vite/deps/chunk-T7ATK2ZT.js?v=e7284969";
import {
  require_react
} from "/node_modules/.vite/deps/chunk-YX2XZWS3.js?v=e7284969";
import {
  __toESM
} from "/node_modules/.vite/deps/chunk-G3PMV62Z.js?v=e7284969";

// node_modules/@radix-ui/react-popper/dist/index.mjs
var React8 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react.useLayoutEffect : noop;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React.useState(null);
  const [_floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var React4 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-slot/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot22 = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React2.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React2.Children.count(newElement) > 1) return React2.Children.only(null);
          return React2.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React2.isValidElement(newElement) ? React2.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React2.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React2.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React2.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React2.cloneElement(children, props2);
    }
    return React2.Children.count(children) > 1 ? React2.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable22;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React2.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotP   rops, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot3 = createSlot(`Primitive.${node}`);
  const Node2 = React3.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot3 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime2.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var NAME = "Arrow";
var Arrow = React4.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return (0, import_jsx_runtime3.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : (0, import_jsx_runtime3.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME;
var Root = Arrow;

// node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-slot/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function createSlot2(ownerName) {
  const SlotClone = createSlotClone2(ownerName);
  const Slot22 = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React5.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React5.Children.count(newElement) > 1) return React5.Children.only(null);
          return React5.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime4.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React5.isValidElement(newElement) ? React5.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime4.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot22.displayName = `${ownerName}.Slot`;
  return Slot22;
}
var Slot2 = createSlot2("Slot");
function createSlotClone2(ownerName) {
  const SlotClone = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React5.isValidElement(children)) {
      const childrenRef = getElementRef2(children);
      const props2 = mergeProps2(slotProps, children.props);
      if (children.type !== React5.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React5.cloneElement(children, props2);
    }
    return React5.Children.count(children) > 1 ? React5.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER2 = Symbol("radix.slottable");
function createSlottable2(ownerName) {
  const Slottable22 = ({ children }) => {
    return (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER2;
  return Slottable22;
}
var Slottable2 = createSlottable2("Slottable");
function isSlottable2(child) {
  return React5.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER2;
}
function mergeProps2(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var NODES2 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive2 = NODES2.reduce((primitive, node) => {
  const Slot3 = createSlot2(`Primitive.${node}`);
  const Node2 = React6.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot3 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime5.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});

// node_modules/@radix-ui/react-use-size/dist/index.mjs
var React7 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React7.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React8.useState(null);
  return (0, import_jsx_runtime6.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React8.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React8.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = React8.useRef(null);
    React8.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : (0, import_jsx_runtime6.jsx)(Primitive2.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React8.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React8.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React8.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = React8.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return (0, import_jsx_runtime6.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: (0, import_jsx_runtime6.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: (0, import_jsx_runtime6.jsx)(
              Primitive2.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React8.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    (0, import_jsx_runtime6.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: (0, import_jsx_runtime6.jsx)(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

export {
  createPopperScope,
  Root2,
  Anchor,
  Content,
  Arrow2 as Arrow
};
//# sourceMappingURL=chunk-JPVZI2IN.js.map
@  +              createContextScope     J      useCallbackRef     @      useLayoutEffect2   5      /node_modules/.vite/deps/chunk-XH2FCAM7.js?v=e7284969            composeRefs    .<      useComposedRefs    y$5      /node_modules/.vite/deps/chunk-MS2BCRFE.js?v=e7284969      eO      require_react_dom      R{5      /node_modules/.vite/deps/chunk-I3XRBTSS.js?v=e7284969	      VD\      require_jsx_runtime
    M5      /node_modules/.vite/deps/chunk-T7ATK2ZT.js?v=e7284969             require_react      {5      /node_modules/.vite/deps/chunk-YX2XZWS3.js?v=e7284969      ^      __toESM    gl5      /node_modules/.vite/deps/chunk-G3PMV62Z.js?v=e7284969      ?@^      React8     6      sides      $      top     .      right      @~      bottom     ]      left   'k
      alignments     Is
      placements     ?
      reduce           acc    ~ 9      side   U       min    Kk.      max    &9!      round      `-      floor      0m      createCoords   =      oppositeSideMap           oppositeAlignmentMap!   Og      clamp"      ES      evaluate#   U      param$      $      getSide%    sc	      placement&      z      getAlignment'   _$$      getOppositeAxis(    YC      axis)   U       getAxisLength*            height+     J      width,      H
      yAxisSides-     ,      getSideAxis.          getAlignmentAxis/   U5      getAlignmentSides0            rects1      lg      rtl2    	      alignment3      zB      alignmentAxis4      6C      mainAlignmentSide5      A!	      reference6      8sI      floating7   x3      getOppositePlacement8   %t      getExpandedPlacements9      h%]      oppositePlacement:      :      getOppositeAlignmentPlacement;      H)	      start|end<      f      lrPlacement=    |      rlPlacement>    "E      tbPlacement?    D      btPlacement@    7H1      getSideListA    !       isStartB    +      getOppositeAxisPlacementsC      ]	      flipAlignmentD            listE   9      mapF    ^*A      left|right|bottom|topG      S1      expandPaddingObjectH    /B      paddingI    Jy      getPaddingObjectJ   z`      rectToClientRectK   FQ      rectL   ).N      computeCoordsFromPlacementM     O]      _refN         sideAxisO   }      alignLengthP    1{uL
      isVerticalQ     +      commonXR    rzm      commonYS    8H      commonAlignT    o      coordsU     ?R      computePositionV    ~4      configW     5      strategyX   H<*      absoluteY   J=
      middlewareZ     K      platform[   "	      platform2\      :6      validMiddleware]    >	      filter^     G      isRTL_      W-s      getElementRects`    a      statefulPlacementa      T      middlewareDatab     .P
      resetCountc     4      nextXd      k      nextYe      6(      dataf   W      resetg      k5v      initialPlacementh   _T      elementsi   E      detectOverflowj     G      statek       :y      optionsl    :z      _await$platform$isElem      Qe      boundaryn   ?U      clippingAncestorso            rootBoundaryp   #c      viewportq   J      elementContextr     9      altBoundarys    lZ      paddingObjectt      W
      altContextu     o      clippingClientRectv     0+      getClippingRectw    6#	      isElementx      i	      contextElementy     2D      getDocumentElementz     t      offsetParent{   e      getOffsetParent|    B6      offsetScale}          getScale~   _|      elementClientRect      _5      convertOffsetParentRelativeRectToViewportRelativeRect      !H	      arrow      k      arrowDimensions    }3!      getDimensions      ~^      isYAxis    "      minProp    [_      maxProp    r
      clientProp           clientHeight   G      clientWidth          endDiff    td2	      startDiff      xx      arrowOffsetParent      
      clientSize     O      centerToReference      O      largestPossiblePadding     
      minPadding     ES
      maxPadding     Fc      min$1      >,      max2   rLt      center           offset4          shouldAddOffset    0      alignmentOffset    \e      centerOffset   Z      flip   q      _middlewareData$arrow      )O      _middlewareData$flip   ,n      mainAxis   9K      checkMainAxis      a&	      crossAxis      0      checkCrossAxis           fallbackPlacements     c?P      specifiedFallbackPlacements    Y%      fallbackStrategy   ZL!      bestFit    E5      fallbackAxisSideDirection      ,      none   ih)I      detectOverflowOptions      *f      initialSideAxis    D;      isBasePlacement    Zd      hasFallbackAxisSideDirection   u2      push   {      placements2    lJ	      overflows      m      overflowsData      T      sides2     c      every      zb      side2      s      _middlewareData$flip2      =.^V      _overflowsData$filter      E7	      nextIndex      ;';      nextPlacement            ignoreCrossAxisOverflow    |D      resetPlacement     }      sort   n      _overflowsData$filter2     g\
      placement2     *~      currentSideAxis    [	      overflow2            getSideOffsets     E      isAnySideFullyClipped      $g      some   v}      hide   HQ      referenceHidden    %      offsets          referenceHiddenOffsets           escaped    n      escapedOffsets     h
I      originSides    W#      convertValueToCoords   ?g      mainAxisMulti      \`      crossAxisMulti     Y      rawValue   B      _middlewareData$offse      
      diffCoords     =O      shift      @[$      limiter    l      mainAxisCoord      E      crossAxisCoord     55v      minSide    R      maxSide    $x      min2   JP      limitedCoords      h?D      enabled    ;
      limitShift     	      rawOffset      k;^      computedOffset     X      len    y      limitMin   O\f      limitMax   1      _middlewareData$offse2           isOriginSide         _state$middlewareData            _state$middlewareData2     =
      heightSide     q\	      widthSide      eVpX      maximumClippingHeight      @M      maximumClippingWidth   Q      overflowAvailableHeight    Q=      overflowAvailableWidth     I29      noShift    v      availableHeight    dln      availableWidth     ;      xMin   |KO      xMax   1      yMin   s      yMax   !      nextDimensions     p	      hasWindow      2      window     <f      getNodeName    &`      node   R      isNode     U5_      nodeName   RDo      toLowerCase    y	      #document      }L#	      getWindow            _node$ownerDocument    J      ownerDocument      &      defaultView    O      document   ,p      documentElement          Node   %      Element    W`}3      isHTMLElement      *q      HTMLElement    k      isShadowRoot   qY
      ShadowRoot     ;$       invalidOverflowDisplayValues  Tn      inline          contents  1      isOverflowElement     |	      overflowX     6e\	      overflowY     e}      display   j      getComputedStyle2           auto|scroll|overlay|hidden|clip	         tableElements
     d      table     (	      isTableElement    4      topLayerSelectors     S8      :popover-open     i      :modal    
      isTopLayer     _l$      selector  ~      matches   A      transformProperties   R|	      transform     uU~1	      translate     $      scale           rotate    ~      perspective   C      willChangeValues  n      containValues     3
      paint     Cc      layout          strict    4W      content   Q-[      isContainingBlock     a      elementOrCss         webkit!    /      isWebKit"  M/      containerType#     4.      normal$    u      backdropFilter%    

      willChange&     v      contain'         getContainingBlock(    S      currentNode)   A<      getParentNode*     5v      isLastTraversableNode+     }      CSS,   XG      supports-  gI      -webkit-backdrop-filter.    H0      lastTraversableNodeNames/  X      html0  h;      body1        getComputedStyle2  zl>      getNodeScroll3     |cr
      scrollLeft4    G	      scrollTop5     ?      scrollX6   m5      scrollY7   [$      assignedSlot8  _
      parentNode9    	(r      host:  >W      getNearestOverflowAncestor;    g      getOverflowAncestors<  u      traverseIframes=   G      _node$ownerDocument2>        scrollableAncestor?    u=      isBody@    Ur      winA         frameElementB        getFrameElementC   $      visualViewportD    2      parentE    e      getCssDimensionsF  V)r	      hasOffsetG     Z      offsetWidthH   Bw      offsetHeightI  Lf      shouldFallbackJ    O      unwrapElementK     H
      domElementL    -      getBoundingClientRectM     #-	      noOffsetsN           getVisualOffsetsO  
      offsetLeftP    D>	      offsetTopQ     Iy3      shouldAddVisualOffsetsR    +S      isFixedS   5w      floatingOffsetParentT  We(      includeScaleU        isFixedStrategyV   YS
      clientRectW    fl      visualOffsetsX     u9	      offsetWinY     )k
      currentWinZ    aQm      currentIFrame[     6      iframeScale\   5b
      iframeRect]    Fc
      clientLeft^    w9      paddingLeft_   	      clientTop`     l
      paddingTopa    ;      getWindowScrollBarXb   E0W
      leftScrollc          getHTMLOffsetd     \z      scrolle          htmlRectf  X      fixedg     *rB      topLayerh  Y?      isOffsetParentAnElementi   
      offsetRectj    I
      htmlOffsetk    s      getClientRectsl    _nU      getDocumentRectm   F)      scrollWidthn   LsA      scrollHeighto  hC      SCROLLBAR_MAXp     X      getViewportRectq         visualViewportBasedr   'AgZ      windowScrollbarXs  ?U3      doct   X
      bodyStylesu    Gt      bodyMarginInlinev  U+
      compatModew    rM
      CSS1Compatx    G$W
      marginLefty    ;[      marginRightz   U      clippingStableScrollbarWidth{   .      abs|   [D      absoluteOrFixed}   /^P\      getInnerBoundingClientRect~    o!      getClientRectFromClippingAncestor     n&      clippingAncestor  N      hasFixedPositionAncestor  L      stopNode        position  KJ      getClippingElementAncestors   
,      cache     a:4      cachedResult  vY#      currentContainingBlockComputedStyle   Eu      elementIsFixed    Z^      computedStyle     )<_      currentNodeIsContaining   p@I      shouldDropCurrentNode     A:      ancestor  z(      elementClippingAncestors  N      firstClippingAncestor     a      clippingRect  0      accRect   ~      getRectRelativeToOffsetParent     <      setLeftRTLScrollbarOffset     T^I\      isStaticPositioned    I*      getTrueOffsetParent   62      polyfill   [      rawOffsetParent   O      svgOffsetParent   5      getOffsetParentFn     G      getDimensionsFn   'i      floatingDimensions    DG}      rectsAreEqual     DB      observeMove   -      onMove    R!	      timeoutId     R      root        cleanup   2       _io   Q8u      clearTimeout  
      disconnect          refresh   !>      skip  z)	      threshold     Sy      elementRectForRootMargin        insetTop  V
      insetRight    [      insetBottom   +	      insetLeft     
      rootMargin    4%      px          isFirstUpdate     !      handleObserve     r
      ratio            intersectionRatio     3At
      setTimeout          IntersectionObserver  d      observe   47
      autoUpdate    c9      update    ]9+      ancestorScroll    Fao      ancestorResize    T      elementResize     '      ResizeObserver    
      layoutShift   2      animationFrame    mQ{      referenceEl   Y 	      ancestors      rO      addEventListener  .a      passive   ?/$_      resize    	      cleanupIo     <O      reobserveFrame          resizeObserver    S
      firstEntry    m2	      unobserve     Wk      cancelAnimationFrame  R      requestAnimationFrame     \      _resizeObserver   j0      frameId   w*      prevRefRect   V	      frameLoop     8      nextRefRect   0Y      _resizeObserver2  ]      removeEventListener         offset2         shift2    ,      flip2     SrB;      size2     !      hide2     V      arrow2    {      limitShift2   b      computePosition2  y_      mergedOptions     	Z      platformWithCache     ,
x      React     %      import_react         ReactDOM  ~      isClient  17      noop  tX@$      noop2     zD`      useLayoutEffect   5G	      deepEqual     ]      isArray   ;	-      hasOwnProperty    B;      key   ^L      _owner          $$typeof  hB      getDPR    TK,      devicePixelRatio  2Z
      roundByDPR    BB+      dpr   ;O      useLatestRef  VF'      ref         useRef          current   f=      useFloating   ?1      externalReference           externalFloating  >:      whileElementsMounted  x5      open  n      setData   ,k      useState  AB      isPositioned  ^9      latestMiddleware  Zk      setLatestMiddleware   V
      _reference    Eh      _setReference     +	      _floating     4      _setFloating  fm}      setReference  #      useCallback   '*U      referenceRef  c      setFloating          floatingRef   '
      floatingEl    cM      dataRef   ;      hasWhileElementsMounted   4      whileElementsMountedRef   / ?      platformRef         openRef   RW      data2     CU      fullData	        isMountedRef
  'u		      flushSync     ?m      refs  \a      useMemo         floatingStyles    euO      initialStyles     B{z
      translate(          px,   l)      px)   Zp      arrow$1   E      isRef     A>      offset3   y      deps  *2nu      shift3    44      limitShift3   w+      flip3     
      size3           hide3     8I      arrow3    #'<
      React4    s      React3    qY	      ReactDOM2     F      React2           import_jsx_runtime!    H
      createSlot"    x	      ownerName#     J-	      SlotClone$     1~      createSlotClone%   1(      Slot22&    /
      forwardRef'           props(     d      forwardedRef)  
}N      children*  	}	      slotProps+     ;      childrenArray,     L      Children-        toArray.   I8	      slottable/     TS      isSlottable0   O5IT
      newElement1     ,      newChildren2   Qj^      child3     Y_      only4  s      isValidElement5    	g      jsx6   N
      cloneElement7  J4      displayName8   1      .Slot9     |]      Slot:  `      childrenRef;   !N@      getElementRef<     Dv      props2=    Ud
      mergeProps>    Mkc      Fragment?  Q
      .SlotClone@    TN      SLOTTABLE_IDENTIFIERA        radix.slottableB         createSlottableC   h)      Slottable22D   wU
      .SlottableE    _		      __radixIdF     |ie	      SlottableG     ,D*B
      childPropsH    
      overridePropsI     gQ      propNameJ  5n      slotPropValueK     O      childPropValueL     xm	      isHandlerM     B      ^on[A-Z]N        argsO  6CY>	      classNameP     >      joinQ  d<      getterR    :      mayWarnS   :J      isReactWarningT          import_jsx_runtime2U   x@Q      NODESV     U~      buttonW          divX   *g      formY  e       imgZ   2      nav[   1<      select\    4PB      span]  a      svg^   u	      Primitive_     v=	      primitive`     Yd      Slot3a     @.
      Primitive.b    V%zb      Node2c     {      asChildd   B[      primitivePropse    0^      Compf  ?      radix-uig  `5U      import_jsx_runtime3h   9      NAMEi  z      Arrowj     aS
      arrowPropsk    -7      viewBoxl   5	      0 0 30 10m     7^      preserveAspectRation   d_      polygono   W+k      pointsp          0,0 30,0 15,10q          Rootr  3      React6s    	      ReactDOM3t     jl      React5u    oI      import_jsx_runtime4v   H      createSlot2w   I      createSlotClone2x        isSlottable2y  ^      Slot2z     
x      getElementRef2{    .)c      mergeProps2|         SLOTTABLE_IDENTIFIER2}     VW      createSlottable2~  n
      Slottable2          import_jsx_runtime5   x[      NODES2    |~
      Primitive2    /      React7    h9      useSize   ew      size4     ^HaI      setSize   M>      entry     h{>;      borderBoxSize     D      borderSizeEntry   Z
      borderSize    s[
      inlineSize    }	      blockSize     v      box   D
      border-box    l      import_jsx_runtime6   ?`y      POPPER_NAME         Popper    )C      createPopperContext   %      createPopperScope     T      PopperProvider    5      usePopperContext   >      __scopePopper     r      anchor    )	      setAnchor     	      scope     q'      onAnchorChange    s      ANCHOR_NAME   V      PopperAnchor  S
      virtualRef    p      anchorProps         context   J!9      composedRefs  ke7	      anchorRef     }{c	      useEffect     V      previousAnchor    ,+      CONTENT_NAME  wS      PopperContent     U
5B      PopperContentProvider     4/      useContentContext     O
      sideOffset    }      align     f(9e      alignOffset   MkT?      arrowPadding  5      avoidCollisions   >      collisionBoundary     qY	      collisionPadding  ;      collisionPaddingProp  C<e      partial   `      hideWhenDetached  "x      updatePositionStrategy     *	      optimized     M      onPlaced  !.w(      contentProps  f
      setContent           arrow4    +TT      setArrow  	      arrowSize     ;

      arrowWidth    G      arrowHeight         desiredPlacement  m`      hasExplicitBoundaries     	      isNotNull     0lK      always    vJ       anchorWidth   H      anchorHeight  49      contentStyle  A/      setProperty   (Zg      --radix-popper-available-width    )|      --radix-popper-available-height   &z      --radix-popper-anchor-width   (|I      --radix-popper-anchor-height  2      transformOrigin   s
      placedSide          placedAlign   -E      getSideAndAlignFromPlacement  a.      handlePlaced  >      arrowX    &S      arrowY    tO      cannotCenterArrow           contentZIndex     Gs      setContentZIndex  f      zIndex    S!      data-radix-popper-content-wrapper     (c      translate(0, -200%)   ;
      minWidth  :      max-content   {T      --radix-popper-transform-origin   1 
      visibility    W      hidden    ;8      pointerEvents     a      dir   D      onArrowChange     c&      shouldHideArrow   (	      data-side     VS
      data-align    k^	      animation     @
      ARROW_NAME    X"      PopperArrow   O       OPPOSITE_SIDE     u!      PopperArrow2  &33      contentContext    &      baseSide  %w#      0 0   }      center 0  AH      100% 0    ?      translateY(100%)  e.      translateY(50%) rotate(90deg) translateX(-50%)    3l      rotate(180deg)    H.      translateY(50%) rotate(-90deg) translateX(50%)          block     [      isArrowHidden     %      noArrowAlign        0%    Z      50%   ?y      100%        arrowXCenter        arrowYCenter  6      Root2           Anchor    #      Content    ]J_      Arrow2    :0      placements<   $R      getOppositeAlignmentPlacement/<   ;[Fm      getOppositeAxisPlacements/list<   Ws      getOppositePlacement/<     b	      flip/fn/<      4=      flip/fn/_overflowsData$filter<    @      flip/fn/_overflowsData$filter2<   |!      flip/fn/_overflowsData$filter2</<     *      isAnySideFullyClipped/<         isTopLayer/<  W5      isContainingBlock/<   #      getClippingElementAncestors/result<   H      getClippingRect/clippingRect<     	,      observeMove/refresh/handleObserve/timeoutId<  ev      autoUpdate/<  #      autoUpdate/resizeObserver<    *      autoUpdate/resizeObserver</reobserveFrame<    ]      autoUpdate/</<    o      useLatestRef/<    F4`      useFloating/setReference<           useFloating/setFloating<  2/      useFloating/update<         useFloating/update</<     k      useFloating/update</</<   vbP      useFloating/<      U      useFloating/</<!         useFloating/refs<"     |      useFloating/elements<#     B      useFloating/floatingStyles<&   g      createSlot/Slot22<'    -Y      createSlot/Slot22</newChildren<(   9FH      createSlotClone/SlotClone<*    A_N"      mergeProps/overrideProps[propName]+    B
      Primitive<,    7H      Primitive</Node2<-     >S      Arrow<.    JE      createSlot2/Slot22</          createSlot2/Slot22</newChildren<0        createSlotClone2/SlotClone<2   (#      mergeProps2/overrideProps[propName]3         Primitive2<4   +G       Primitive2</Node2<5    '@	      useSize/<6     e      useSize/</resizeObserver<7     n      useSize/</<8         PopperAnchor<9     D%      PopperAnchor</<:         PopperContent<;    x      PopperContent</composedRefs<>  e      PopperContent</<        F  G               %,                                                                                                                                                                               	                  
                                                                                                                                                                                                                                                                                                                                                                                                                    !                                 #                $                                  &                '               (                (                 (                +                ,                 +                  +           !      +                0           "      1                 0           #      3           $      3           %      0           &                  '                 (      8           )                 *      :          +      ;                 <                <                           ,      ?                            -      A          .      B                           /      D          0      E                 F           1      G                 F                F                           2      K           3      L                M                M                           4      P          5      Q                R           6      R                            7                  8                  9                  :                  ;                  <                  =                  >                  ?      ]                             @                 A      `           B      a                             C      c                d           D      d           E      d           F                  G      h                             H                  I                  J                  K                  L      n                             M      p                             N      r                s                            O                  P      v                             Q                  R      y                             S      {                             T                  U      ~                                                             V                                   W                                   X                                                   Y                  Z                                   [                                                                   \                                   ]                                                   ^                                   _                                 `                                 a                  b                                c                                   d                                   e                                f                                  g                  h                                   i                                                  j                                  k                  l                 m                                 n                o                                p                                  q                                 r                                 v                                  s                 t                                  u                 w                 x                  y                                                   z                  {                                                   |                                   }                                  ~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
                                                                                                                                                                                                                                                                                                                                                                                    !                                 #               $                %                                 '               (                )               *                +                ,               *                                  /                                  1               2                3                                  5      
         6                6                8                6                :               6                6                                 >                ?                                                   B                C                                  E                Oc      	              	                 >  P P{ P   P P P/ P&  P P P  Pw P Ps q P^ PU  P P  P w  P@  P P P P  P P   P8  P! P PZ  P P. P P P9  P/  P; P$ Px P  P} PF   =  P Ph _  J  P u P  P  P P P   P Py  PB  P P  P M P-  Po P! Pz P) P P:  P| P   P PE P Py G  P!  P P  Pr Pi  P; P P P	 Pv  P ?  P   J Pl PU L  P   P  P@ P7  P  PB P P P{  P   P P P  P,  P: P P  P P   <  P P~ Pg P  P^  P'  Pc    I  P2 P Pt P= P P  Pa P  P P* P P   P  P P  `  P P  PB P  P P$  P}  P P P  P P"  PQ P PL P~  P  P P' P Pi  P)  P P} Pk PT P  P Pv P P P P P Pc P PN P| P.  P  Pp P `                              v                   {                  #               %               %               (               (               %               %               %  0  1              4  2  3                 %               9               %               2                 A  1               %  C  \   1              D  2  P                            %                              H               H               K               x  y  +  *               M  %  1              5  6  T  N  3  O    P  Q  R  S               5  P6  PV  Pn  `            0  x  y  `  a  b  %  W  Y  [  \  1              i               8   c  d  e  f              j  Pk  Pl  n  `             x  y  [  0  h  W  m  o  q  r  H  s  t  u   u  K  z  |  ~               k  P             j  Pn  `                   H        0    (        y    %    T  a      u     s      x    [    h                   k  P            j  Pn  `                          g    P  0  j      P%      a        C      [  h  1                                                                                d               d               a  b                              d                              d                                               a  b               j  K               j `                            k  P             j  Pn  `             0  W                 j                 j                 j  Pk  Pn  `                3  %  [  h  1    2  P                     k  P            j  P    n  `             x  y  %  a                 k  P             j  Pn  `                x  y  %          T  j                     M              B                                                         k  P            j                      x  y  %  0  a        T                                                               k  P            j  Pn  `                            +  0    *  %  2          [  h  j                                                                                                           M                                                                           u                j                  u                u  `                                                        J  `                                                          u               (                                             u                u                                                             8               D  < =              > ? @              A              @              u               +  *  J   F G H I              u                u               x  y  K K  +  *  $               u                @              u   R S              u   T U z               x  y  +  *  V K W             Y Z @ X              [ \ J                    u   K               b                d              e x  y               M              h  K  z  W  d  R   g   h j              i              u                u               x  / d 0 +  *  y               u   W              +  *  x  y  @ / C r    	          q              s 0 t u z              u   W               V      +  *  x  y               u    W              K               W              u                 8              u                   ( P                                                          M  t               u  `m  o  W  P n                                K               u                +  *              u   z  W   	         	   d h   PR K    Pj x  y                     	          i              u                u                              u                z  @                          e  Pn  `t                                u                a  b               u  ` P P P             ` P P                             P              P P    +  *       k               ~                                                           5  P6  P Pk   P             P P P P P P   P P P P                                                         M                                                                        5  6  k                                                             a  b                i                                u                @              u                                 `               P                             k  !   	       !    P P  P  P W  P P P%  P P  P	 PY   P P  P  P P[   Ph  P  P P P Pe  P  P                                                           V                               P                                                                                                                                                            x  y                               k  P P                            j               u   H               k                k                k                k                k                k                k                "              # P%              ' (              ) * + . P             0 P1              2              "              #              ' (              ) *              : <              "              C                 )              2              * G              H              I              J PK PL              N                             u               Q R              _   P             ` Pb              ' (              c d e              ' (              ) +  *  j              "              # P%              ' (              ) * + . P             0 P1              2              "              #              ' (              ) *              : <              "              C                 )              2              * G              H              I              J PK PL              N                             u               Q R              _   P             ` Pb              ' (              c d e              u  `               P                               P             ~               +  *                                               '               )                ' (                P  P P  P                                           ' ( )   #       )            P          P %    P a    P        P     P m                                N                               h  0                                                                                 ' (               j                               k  P             e              x  y  %  0  a                        %                  0;     F          M     M     I$KE    $                                                  {      
    x  y     $                               {   {                                                                                                                           (      +  *          x  y     
      x  y     
    x  y     
    x  y     
    x  y     
    x  y         5  6  W          	   -      x  y  g  %  W  a  0  Z  h     
     5  6         5  6  W        x  y  %  W  a                 u   m  o  W           x  y  +  *     
      x  y     
    x  y         h  K  z  W                            8  k                      
     x  y                          8  k                   C             
   %       
    e  f     
                %          f          %                                         8  k         W          e     
                e     
                                               3            3     
   x  y     
    x  y         8  k                    x  y  e                   8  k                         
     x  y     
    x  y         x  y               
      k      
    x  y     
                      8  k                    f          0                                        
     M     Q                      -                                 6                                  ]      $                                      /     0          
   3 4    
    3 4        +  *  $     
   x  y     
    x  y         +  *  x  y     
      x  y     
    3 4        +  *  x  y           +  *  x  y           +  *  x  y                X      f        +  *  x  y           x  y  +  *           +  *  x  y     
      +  *     
    3 4        x  y  +  *     
      5  6         x  y  +  *  
   2        y  v  {  _  k   }  w  ^     
                                                      x  y  W  %  a                 %  W  Y        5  6       
      5  6                    %                               8  k      
   u   H             
   u   H                )         )         )              a      V     W     X     B     C     Y                   R     Z          p      [     \     ]              c                ) +  *        o         )         )         )              a      V     W     X     B     C     Y                   R     Z          p      [     \     ]              c            
    +  *     
    +  *                     )    
           A                           H  m  r        W  %   h  Y                   5     
       3     
    u   H     
                  )    
          #          )    $                                        )                                         8  k             {         e     
     x  y  &!!       ex  
         #                      u  u    <    K  <    W   K  L   o   j    u      L    g     L	    +     L
    x     L      o      <    v  <    5     <       d  <    i  <    -  <      <    S  o'      o)     o*     o-        <.       |  o0     o1      o2     o3        <<            <>       Q  <@    "  <B      <C    c  <D    &     <H       #      u  ;   =     <\       C  og     ;i      >j    7  >k    R  >l    _  >m     >n      >o    [  >p      >q      >r    n  >s    !     u      4          b                E  ow    	          u  u            u  u       x    u  u    y     oz   
       C     L{      D   
  D      o      o    9  o    a  o    $  o      o    J  o      o    r          u  u 	          u  u        x    u  u           u  u            u  u     >      u          u  Y         u           u  u    <       L   o   ;   u            u  u  l       	  L   o   u       O                u  u  L      x    u  u           u  u  s          u  u  0         u          u     ,      u           u  u  P  <       L   o   ;   u            u  u  6          u  u  ~             u el      L           M                    M                   Mw  fL   u  f L                L               5      u  f L                   L                     d         u em      L           M                     M           O        Mw  fL   u  f L                L                5      u  f L                L       O              d    o         O            L   o   u        O       y      y  u em      L           M                     M           `        Mw  fL   u  f L                L                5      u  f L                L       `              d       L   o   u      y  O       G  <         L   o   u      G  O   o                   j     .  00	000@`VPI`+`+`YP(` ` ` ` `K%`K+`KA"`	I\`+`+`+`K  `K b`J `J `J I#`	I o`J `J `J `J 4`	I %`	 `K `+`+`K 0`	I ,`PI `H '`	I `J `%****)****@ J`*`*`*`*`*`*`*`K b`VP)`VP(`VP)`,` `@ A`K `` ` ` ` ` ` `K ~`VP `VP)`VP `VP)`VPI `
PH `PI `PH `VP)`J `E E PI `VP)`*`P8 `.` `VP)`VP `VP)`VPI 8`PH I`PI R`PH }`VP)`J `E E PI `VPI `VP)`*0`P *`P `: `.`+`,E P8 `/`+2`P `,E P8 	q`/`+`K 	y`P8 	` `K 	`*`*`*`0 	P                   (                      d           	           	     l   yl   3                           L        ( W  M(    ( W  M(u  `
		PC@   U-@                            ;     >     >    `%((X   rX                             +      g     u u  `PPQ`   ?$F`   -                                     u             `  $PQ@   w@                              L      u M `PQ@   d_x@                              L      u M `PQX   bX   .                                                    `QX   X   .                                                    `Qx   {Ox   @                          d  L         u u                       `PPQP   [MP                             o    <     u u  `PPQ  j  _                                                u         u         u        ]                                 
         
      
   2   
                                 L	     M L
     M        Z      u       j      k     Z      u k     `-`J`P(`P(`P(` ''` `)PM`	PT         ^      \            /   M                           Z     u    j    B     u k       k    B      u k    &`P(`P*	PT          L       J          L   kw)L                              L   n   o   u  `
PQ0   s/0   
                          5    M `	4  ?,4                    	            B         1                  t             1              -         i                i         -                         S        j     ` ``0F`06 `06	 `5Q@  k                                     u            u      u       U         L   o   u     0   	      L      L   B  u u           ++`P)`P	P(`/`P(	`-`	PPM	`T@                         <   6[B)<                                 (      ( 
`	L   Z&L                              L   n   o   u  `
PQ0   0   
                          v    M 
`	`   O`   .                         :>   >   >   >         y  `"&&&&0Q   	R   Q                                  H     u /      ;     >     >     >     >       `  2P (((=Q  m                                     gL      L     L     L     ;     >     >     >      >        (>	       (>
      >     >    @` `%))))**)9T                          H  S<(  E                L                         	  
    gL      L      <    u        u         u        u             L      L   -(  L   -)     L      L   -(  L   -)	       M-    M-)
          B      	   f      
                        ;     >      L     L   )>        $   ;     >      L      L   (>        *   ;      L      L   (>   	  >     e   0   ;      L     L   )>   	  >     0   6   ;      L   >      L   >     ;        u        =      `   >      >       1M
      A     A      B      B   B   ,)0QV   E       1M
      H     H      I      I   I   ,(0Q   L      @` `P(`P(`P(`P(`/`	 `	 `&` `%	)		@` `%	)		@` `%		/	N ` `%		/	N&` `%	.	@-`P `( ` `( `J5`TH         D      B           )@    "             e      9                                   	  
       gL                  L                  L          j         L   	    L   	   u 
  	  L
               	  L
      u                           	  L   ;      >      >     >   u                        V          u gL     L         ;                
  L   !                 
    MgL     L        ;     >     >     >     >     >     >      >   	  >   ;      >      >   >   u    1           1   1   gL     L     L     L          7        7     7          9        9     9     :      y   1:    M    y       y A       E     2!F   %  G     2*       K     L      M     L     N     L      P     L   e   R   	  L   ;       >      >     >   u    Y           Y   Y      Y     L   Z      Z   V          u gL     L     ]     ]                 2*  _     ;!     >     >     >     >     >                      	  
    :                      	  
     e            e         e    !@`0@`P(` ! P ` %**I	P0@`P `)`*`&`f @	`@	`	%))))))))%	*	OP@-` ` `" '	 	@6	` `+` ` `@<` ` ?%**I=:P0A@C
`@F(
P@H`@/`@K`%))))9RP    P  ?           #          M                                      5          #     	  a~  ~                     9                            	  
                             ;            gL     L     L     L     L     L              u gL	          
        L                  L                	  L             
  L               p     u   	                              
                	     M  /     L   ;     L                 L     u        !            !   !         #         #   #      $     |   $     L   i   &     L      )   !   )     L     L   u ,      -           -   -   >     >	     >     >   u    3           3   3   u   	     L   6   ;     >     >     L   L   >     L   L   >      ?     L   @       L      C   !   C     L     L   u F      G           G   G       L      J      J     L     u L      M           M   M      N     L      Q      Q     L     u S      T           T   T      U   ;   >   >   X      X   ;   >   >   [     /     L   l   ]     L   ;      >     >!     >"     >   u    e           e   e      e     e   u   ;#     L$     L$   )  L$   (  L   ->$     L%     L%   )  L%   (  L   ->%     L&     L&   )  L&   (  L   ->&     L'     L'   )  L'   (  L   ->'                   	  
                    V                   	  
                                               `-`0@`@`		P0L`P(` ` ` % H P    &	P ))I?P PH` ))  ` + #	P ` % P ? P &%&@+`   %)))I+  P00I+-PH1`%	

/	$

/	!

/	"

?7P	      p  #  l  E              1                          K  \   	6\   -   	                          ;      >      >   o   >   	`%**	J=	  Cp`	           &             9                           	  
                                               gL     L     L     L     L     L     L             u    	   ;	   
   gL
     L                       ;                      	  
                                                 p     u   ;     >     >          u        u     L     u                      
                                                                                      L     M  L     M(    M)  L     M)	      M  L     M)    L      .      .     L     u 0      1           1   1          2       M   3   3         j   5     L      8      8     L     u :      ;           ;   ;   <   ;   =     L     M   @     L     MB      B   	  -  -)     -
    M-))  g       M  u   g       M  u          
    M)  )     -
    M-)  (  I         u     L      Z        u j   ]       V   _     L     M-       d        d     d   )
    M-)i       C   j          l       )   m       )n      n   n     :  1    M  (A:  1  A    )  )>        z   ;     >   |       y >     >                      	  
                                                                  	  
                                                                      @		`@	`		P0L	` `E9O`P(`%)N`P(`P(`P `/` ` ` `
 `	 ` + #P ` 	`  & P `@$`-$` `	P(`	P(`)`
*`*`P(` &P . *	 # `    `"&"	*	
*	 @7I9P	  	  l	  ^    K                           A                         C   P   	                                   ;         ;      >      >   o   >   )`-`@`%**:lQ  f  
        &             9                   	  
                                  gL     L     L   	  L     L     L            u g;    >	    >
    >    >    >    >   L	               L
               L     L                  L                  L               :    y     L               L       l   !   ;           	  
                                N  "        u   <     u         u       L      )   !   )     L     L   u ,      -          -   -       \   .        /     0   &   1   j   Z     u k       3        u 4                  7      7      8     L   8           u { b   <   Mw  fL   j    @       u  f L      C   L   lE       E   E   zF   j     k      Mw  fL   J       u  f L      M   L   lO      M       u    Q         Q   Q   
  j        L        U      U     L   V      W   j    X       "   Y     L   
    My \     V   ]     '     	    u     L   
    MM
    MMy   d   j     Mw  fL   h       u  f L      k   L   lm    ;     >     >   l    L   o    u   u           L        x      x     L"   y      z   z   (      M    1  }       $   "         <     u                      L   o%   u          ;&   ;'     >"     >   >(   ;)     >   >*                   	  
                                            L+   o,   u L-   o.   u M                L                                               L+   o0   u L1   o2   u L-   o3   u M                M                                                  ;4   ;5     >   >*                 	  
                                               ;6           	  
                                ^           	  
                                                          @	`@`		P00,	@` 	`Ec@`P(`P)`P*` ! 	P "` 3 P @P-,` ` 	`P  PG`
 `P `*` 6 `.	`	PI&`&`P(	`P@*` %	)	@.`P ` 7 `.`&+` 5P `@6 P `%%)N<%NcEB`-P
(P > `.`  #`.PJOP
  P * `.`NS`0U `)`JZ`/`%%NcFb`%P                
      S            s  L       !   X        #     '     !   }  k           \                  /           !   	           q	  \          	     
       C
                 .         f  .           .              
  ,   ,                              ! `	t   
t   C                         <     L   u               L   M           `P '4   24                              L   M! `@   SI@                              L   M L   M) 
`
   0   e                             S         <     L   u                                ` &+`P(`0OI`!Q         I       [          |   9MP|   ?                  	       j     L   k      L   L   o   u L   o   u k    `P
,P.,   Z,                                `0   q0                               ( `4   N4                              M M) 
`      _                         ;     L    L   )>     L    L   )>     L    L   )>     L    L   )>    `%...>QP   kP      	                          K  L   o   u )`PQ4   #+4                                 M" 
`   CL   P   	                                   ;         ;      >      >   o   >   )`-`@`%**:0Q,  rQ                 (      9                  gL              u g;    >   L                  :    y            
                     M      :  	    y 
   >   u                                L
   u   ;   ;     >   }     u >   >                           M      :  	    y >   u                               L   u   ;   ;     >   }     u >   >              @       '   ;                     (            (         (    @`@`		P0 	@` !*`" J
"P@`
	P(`%%)'PM'@*`" F"P@`
	P(`%%)PM'0# `E'P,                                  v                                   I            X                                    _Bt                 7      9                               	  
         gL     L     L       L         !        L     L   u 	      
            
   
          u        u   <     u    	  |  L     u                
          	                               u     )      ;	     >
   >   >   [      ;     L
            >
     L              >     L   >   #   gL
      L     L          '     (   =   )           +     ,   ,     ,     ,   	  0   -   ;       ,>      
  ,>   +   2   ;      
  ,>       ,>   7                      	  
      >                      	  
       7            7         7    @` ` ! 	P `P(`P(`P.`P ` `		P@` )&%  @` `@` *%*?$P    x           c      A                    }     mA>   L   	                                         ;      >      >   o   >   )`-`L`%**:Q  6X                       9                     gL     L     L     L     2        u                            L         	      	      L   
   .        L             L      ,      ;	                   ;
       L   (>       L   (>   :      y   >   >                                                    @` `P ` 9 	`E@`%	/	/	" NP    \                 *                                      C*   P   	                                   ;         ;      >      >   o   >   )`-`@`%**:GQ4                   L      9                           	  
           gL     L     L             u g;    >    >    >   L       
   
     L               L          ;	   o
   >        :    y   ;     >     >   	  M        u                      
  <        u u   o     u   	    M   	    M                          !         !      !             #         #      #        
    M(     
    M)  I          u            (        )                   +         +      +             -         -      -       
    M(    
    M)  I         u           2     L   :       y   1   A  1  Au   :      y ;     L     )>     L     )>   :  1  A  1  A>   >                      	  
        B                      	  
         L            L         L    @`@`		P0%@	@`%	)	N`P `PP(`P(`.`.` ` ` `/`/	`P@'` ` ` `/`/	`P@.`"	 	*	J.%PH3`"	 	%	*	*"*@>P4  $    t                                      ^                         -}|   A                              gL      L     ;      >     >    
@` `%)I	T          @       >          |   zj|   F   	                                   ;         ;      >   o   >   )`-`@`%*:@Q$  PW.                  `                    	  
                gL     L     L     L     L             u gL             	  L       
   
   
  L	               ;
     >     >     <     u   o     u       M      M     	    u     #      ;     >   >	   +      :>   >	         y      
                      !         !      !       L     M  L     M)  L   (    L     M  L     M(  L   )         1       &   1           3       3   3       4                   6         6      6     |  L        u u     L     M  L     M)  S   ?     L         B      B        MC      D   D      D   D   (     F      F     L	   G   (    L     M  L     M(     N   I   N     L        Q      Q       MR      S   S   (     U     L	      V   V   )         Y       &   Y           [       [   [   :  1  A  1  A @`@`		P0	L`%	)	N`P(`P(`.`.`		P(` 	)	"	&	&	@`.` `/`/`/` `/`@(` ` `PP(` J 8 ` O 5 `/` `/`@4`"	*	J8T$                                                  Cd   P   	                                   ;         ;      >      >   o   >   )`-`@`%**:MQ	  H^x	          #       w      9                      	  
                               gL     L   	  L     L             u g;    >   L       	   o   
     :	    y   M        u                             u        u   <     u 
     	  L   gL     L                                            L         !        L     L   u        !           !   !      "         "      "      $         $      $     E   $               &         &      &     &       L   )  L   )      L   )  L   )  g         M)  u 
  g         M)  u      L   L     
           L   L        ;     L   L   =      >       >      L   L         B      L   L
   D      E       E        F     G   |  H           +     L   u   +     L   u   +     L   u   +     L   u     w   Q           R      R      S       (%   T   +     L     L   u W   ,)  r   Y           Z      Z      [       (%   \   +     L     L   u _   ,)  a           a      :       y   >     >   u    h           h   h     L     L   u    l           l   l         L      o       L   q      r   ;   ;   >   >                  	  
                               v   ;!                 	  
                            b                 	  
                             w            w         w    @`@`		P@	@`P `P(`P(`P@`&` 	`)	` ! 	P 	`)	`@%`	
/$`
/'`	
P(&`
P(` `)`)` 	`N(` 	`N+`  `
P(`
P(`
P(`
P(`.` " 		P ` " 		P@6`"	 	)	I6P@;`	P `
 # 	`%%KD@C`%P	  	  	  -  9    4             4  r                       V                      $   5$                                	4   T4   	                              ` Q   ,Q5   J                               u 2        L               L   u         `P-` P3F`Q   [_   ^                                  L                        L                   ` MQ   7   {                 
             u         L           L               L            	      	      L   
    `P QQ   %H   J                          D   u                #          :     u L   #    `P-`1F` 
PQ      J                          D   u                #          :     u L   #    `P-`1F` 
PQ      J                          D   u                #          :     u L   #    `P-`1F`  
PQ   Va   b                          D   u                             #    	      :     u L   #    `P `1F` 
PQ  Z                                         u gL      L     L     L     n   L        (  (u    
      L     u     
@`P `.P*"PT                          T   }T                             Q  L    m     u u  `PPQP   DIP      	                          "  L   o   u )`P3Q   T|   7                       $   L     u                 !`PCN+`AY         !          /                          Z                  "               u          u            u                 L   o   u         L      
      L                        :         L            L                        :         L            L               >      c  L   o	   u       &  L   o
   u "    +`.`
P #P ` P  K QP NPT                       `   5`   8                                 M           M             ` %d   nd   2                               L               L     u  ` Pd   6
d   2                               L               L     u  ` P  [<                         $    @     u        1      u        z      u    i       3      u          %             u    
   
    @      u    k    
&`P(
fPP 	`P-`4M`P-`1H`P@
`T  |                o                                                      X   N                  
                     L                  L         u  `  `1F` PQT   T                             #  L    m     u u  `$PPQT   K{IT                             :     u L     u  `P
$PQ   ip[   \                               u *      ;     L   >     L   >      ;     L   >     L   >    `
P-`%-=F`%-=Qd  #4                             m     u                 L   Y        L   F       X     u    	     L   
          7     u        X      u          L                &`P `38@` 	P 	PM`PTd                '                        l  l.',                             @     u     z      u C        L           L   L           L          1      u    
    h      u                 e      u  &`P(`P-`0	H`P "P `4	H`"PTl                f                                        L                                     j                    e     u       L         	      	      L   
      :     u              \     u    L       L         j        h     u               j                          (     u       j       u     L      (     j     u u   `	-`N`-`J`P(` 5 `
P(`&`P(`
 P A 7P wP3J`
PPT                           m            n                        !a   S                           L   "         L     L   u            L             ` +PQ  
#  o         
                                  u         L   u                   L   u    	   	      1     u             L                           L                 x      u          x     u                            ;      >     >     >    
 `P(`	P `	P `P(` ` `P P/`.`)`N`%))9T         n      l         d   (d   2                               u         L               `PQ  `           
       %                      T     u    1     u           u      L   u     F     u gL     L     L       !       x     L   u         L        -     !       x     L   u         L        -              L      u                           L     u !      "     "   ;      >	     >
    
 `P(`P-`P3H`P@
`P ` 
	P "*` 
	P $*` P `K` P `K`%)9T               R                          m                              :     u        u           L             ;     ;      L   L   >      L   L   >    
&`
P(`P `5	H`% 0	T                 L                           O`   b                                     )               :     u               `-`J` =
P `1F`Q  xe                  U      $                                         L   u     T     u       u     ^   	    ;   
        u            u                   u               u             u           u        L     L   (   L   -    L     L   (   L   -    L      L   -    L      L   -    %  #     	  
     :     u 
      %        u &      '    :    u    (    (     
     \     u 	  )   	  "   *       +       ,   Y  -                 	  u   	  L   u        	  u     L   	  L         L   u (  L   ,(    L   	  L         L   u (  L   ,(      L   ,0      L   ,0      L   ,0      L   ,0      (0      (0   :   	  u    \     u 	  {O   O    /   ;     >     >     >     >   u  7 `-`J`-`J`
P(`P(`P(`-	`-`
P-	`P0 `PM`P ?P P-`	
/`	
/`	/`	/` `
P(` P $P `)`P(f /  `	P(`P(`P(`			P `			P ` ` ` ` `/`/`P(` P@-`%)))I-
P33T             	           
   ~  J                         C       '   b                 	          q     u L       ,           7     u u L      (    L      ( &`P-`-`PP:5H`T          a       J              _             (#s   {                                L   u        L    L   ( w        u )     L    L   (  ;     >     >	    .`
P(`		P)`	.`%)9T          z       x            
p  b                R                         	  
      gL      L     L     L             7     u      !             L   u    	   	                                       ;   >	   >
         u       u 	   1     u 
  
         
                    m     u           h     u           q     u       1     u o               u         u   	    L     L   (O   	    L     L   (O   *         +   
     -     .       /           u    0       u 1     ;     L     L   ,>     L     L   ,>     L     L   ,  L	     L   ,)	  L   (  L   (>     L     L   ,  L
     L   ,)	  L   (  L   (>    @` `/`P(` 	P ` `4&H`%&K`P(`P(#`P(`  	`P /P `PM	`P&`P(`P(` `@`  P )P-`%	/	/	

	

/	

	

?&T         a                     e           _         P   P                               L     L   u  u  `
PPQ   d   a                "                      7     u    q     u     L   L      +     L     L     L     L   u    +     L     L     L     L   u     L    w     u (     L	           u L
      5          +     L     L   u   )(0      ;     >     >      >     >    
 `P(`P(` `				P(`				P(`
P)`/`P `
			P*@`%)))9T          `      ^           4=l                  4                        :     u    7     u     L       L        L                     L        L         u      #                     &        L	       L
            w     u     !       	  
        L       L   	      	  u 
    L      E          
  L   u     
  L   u (   "   "      "   "        L     L   	  L   )  )u      =  !   +        )0   ,   -   ,      =  !   .        (0   /   ;      >     >     >     >     `
P(`P(`.`.`.`&`&`&`.`.!`.	` `.`@`P(`  `.`.`P(` -	P$	P *`		
P(	`  `@` `@`%)))9$T                           8                        "  -                                                 u       L     L   (     L     L   (   1     u    
         u           u        L     L   ,    L	     L
   ,      L   ,      L
   ,  ;     >     >     >     >
     `	P(`	.`	.`P P P-`/`/`/`/`%)))9T         ,      *           \6  )                                 #             u              )       U    7     u u               u #   	         u    t   
           u   ;    L     L   )>    L     L   )>    L   >    L	   >	          /      u  &&` `	P ` `PP `
P-`"P 
&`P(`%//-@`PT         (        j           &         @  a                             @     u        1             u        z      u                    u L                    u     &`P(`P /P `1H`P OPT@                b                          k                  5      $             L     u                (     j    u L   o   u           u L                @     u                        u       z      u                     u   3      u             L                      )                           N        L      4   "     #   %   C  L	     L   u (   E   )   h      u ,   +        -           u .       '   /      L   o
   u       2       2   @      u    *3    L        y      `

P(`.`4H`	P
P(-`&`P ` P 
f
PP $.`P(%`P(	` `K#`  ' C  <	P GP" 5	P-	`.`P `N`P@`

	P$`T                @                                               h   jh   /                              u       m     u        `
P P8   8                                     `  ^<T                 *      $                    gL      L     L     L           R            u       j    !   	   {         L   u          j    L     u      j     Mw  fL	          u  f L
         L   l      l    M    L   o   k           u u   ;     L     L   )>     L     L   )>     L   >     L   >   @` $` .P 7		P :P-` +!`+`E"	PC
*PH`%	/	/.>T  t                                .   P  Lp0                            k                u      +      L     L   u O     g      L     L   u O     g      L     L   u O     +      L     L   u O      &`"
	
P(`		
P)`		P)`		P)`		P)`#TP                             D   J                             F     u gL      L     ;      >     >    
@`P `%)9	T          I       G            )^        	          A                       o      1    u   7    u                  u   ;   >   >        u          
                      m    u          h      u          q    u        i               u        L	    L
   (O	        L    L   (O   "                   y            !        #      #      $       y  %          &        (     )   !   *           u    +      u ,       L     L   (   L	   )  L	   )    L     L   (   L   )  L   )  ;     >	     >     L   >     L   >    " #`P(`P)`.`	P(`%&K	`PI`  	`P /P `PM	`&`	P(`/` `/`N` `N`   P )P-`	
/`	
/`%)).>%T             .  Z                    T   M&"T   $                                w         u O    `  
P)PH   PVH                                  u L       `PQd  L$                             1     u "            u L                             u 	     L       7     u             L   L             &`P ,P `1H`-`P3H`-`P/`@`Td                G              f                          C<$                   "      $      :     u         u             1     u          @     u               z     u 	   c   
         u             u                @     u   z         f      u          0       ^      u              u    $       f       u          I       z      u 1             u        3      u                  &             u    "     "    *`
P(`P-`4H`P&`P(fP `
PP 	`4I` P@`4J`	P(
f P 3P `#P@` &P :P$P `4H` *PT                 7             S                                                                                            j               c      E  {                     9                    L         _          L           L   u                        ;         L         L   u                        L   u >   ;   >	   >
     L   >     L   >   >                                            .` `.`
P `%)

P "
P(%&&.0P                   1      4                    K  H   PVH                                  u L       `PQ   a|   l                           L    L   T        L    L   8        L    L           L    L       `   Q   s5   d                                   o     o            7     u       y     `'`PIG`P$`T         L       a                V                                   y                   L   y               `
P$` P)` P  K    	             8      $                       	  
  o                                   y    L   u        gL     L     L     L                y                                 u          L       ()u        L	       ()u        u     
   (  (
   (  (
   (  (   (	  ;   	  >   +   g     u u    ,   ,   >   
           :
      y   L   >            ?   4              
           6       L     y 	 	`	-`J	`-`L`*&`P@	` 	`-`O	` 
 `A<H`P(`P(`
P(`P(` `%)PP@`72!`"	@6	@3P@8+`P@;` P%P                            S  2                  K     vT                             ML           x                     u        1          o   u          
         y       .                 L   u  u             y               
&`/`
 ` `PCH`.`5	CP0
 `PI` 
PP 	`O` P               H          @   *u3B@                                
Hz>y  ` P$P  auvt                 B      $                     o            ;        gL                L              	  L       
            L          	        L
              
  T     u              	           j             (      u       j       Mw  fL          u  f L         L   l!    (     u Mw  fL   %       u  f L      (   L   l*       *   j    +         L   o   y       /     /   "   0   ]        u    1   1               v   2      o               6    
  7      8      L      y :      L     y <        
     =        u    >   >       
     ?      y  @      y  o    ' `-`>@
`0  M`P)` $ &P (P `PD` )P `(`'`.`$	PI#	`  `PI&`P9('` 'P `/`O5`*`5CT           w                       .           .      ;BHE   p                               -        L        ;   >   y     	   	  "        L        y     ` 6%F PI` 6P)P  
3  Z                      $     eA      L           M             n      Mw  fL   u  f L                L                     d          4         L                        L            L     y           y 	    o
   u          y   
&`  ` $ 	` P$	`
P$	`'PN
`+P           Y              h   h   5                                           L     y     ` EP)	P                                      u                         u             y                       u           &`P(	` P `O` ` P P               RQ                                 L   o   y                 y                       L   y  
             
   
                  y     ` PD` P)` ?P)` 	` `
PIP   ~z   e                               "        L        y     	   	  "        L        y     ` 9P)` 9P)P  WT                                           : !  >        y   :  L       y    >            :      y   >   u  ".!` `"*@`" N
`
" I

P3T                          $   q<$                              @  n            	       C      $                                 &        L   u   L   u                                            '        L     u         L          L                      2+   ;       %       M   Mu    !   !   !   !      L     u     L            L    u L      +   +        +     2+   B   .   ;   L	   L
        Mu    4   4   4        4     2+      7         M          :     L   ;      <   8   <    %       M   Mu    @   @   @   c@   @          B     C    .`.`1.H`/`1.H` P
P `1.8
&` 
 	`P-`-` 
`1.H`	f `P-`1.@`1.H`P(`.	`P `1.H
`	f ` 	P-	`1.@"
`	f &`.` 	`K'`P-	`1.@+`1.H-` T@                 "              >                                         `             s                          "            Z  y               	           	                                                  P            W          ;        $   f                 	                        L   L                     L      	   	    
&` `1H` `T          e                     c             g|   8                                u       L       ,u    - &`P(`PT          7       5             s   A   	                              L     u       o   y    	%`P)`PD`T         2       >          @   ?R@                                     O    ` P   `  	      	                $                              ;          gL                   L                   L       	   j    
     L     L	          ;
      gL     L     L                L     L    	    L   ;   >   >      >      >   ;   >   >   u em       L        #   M   $    $           &   M   '    '         '   Mw  fL   u  f L      -       -   L   .         /    5   /   u  f L      2       2   L   3         4      4   d 5     L     u el   9   L        <   M   =    =           ?   M   @    @        @   Mw  fL   u  f L      F       F   L   G         H    5   H   u  f L      K       K   L   L        M      M   d N   %           u    P          y Q     L   u el   U   L        X   M   Y    Y           [   M   \    \         \   Mw  fL   u  f L      b       b   L   c         d    5   d   u  f L      g       g   L   h         i      i   d j     L   u el   n   L        q   M   r    r          t   M   u    u         u   Mw  fL   u  f L      {       {   L   |        }    5   }   u  f L                L                     d      L   o   j    u      L   o   j    u  
                                          L   u      L   u      L         u        A     u    A     u    A    	  u      L   o   j      k       k      k      k      k   u       o    j    	  k    y   L   u       o!   j    y    o"   j      k       k      k      k     k   y   L#   o$   j      k     
  k   u      L#   o%   j      k       k   u      L#   o&   j      k       k      L   k      L   k      L   k   u      L#   o'   j      k       k      k      k      k   u  
 `-`>@`00@`%&&***F!P@3`P `
P-`	PI'`P %`P `E$EPI%`E*E%PI+` ` `P)`P)`
P)#`+#`P)`P)`P)`EP




J4PIQ`EYJQPDZ`P)`E`E[PDa`Ej



IaPDk`Ep
JkPIq`Et
JqPIu`E  


Ou PI  `E  




J  P3  T           	      	               4                      v                                 :           )           x     |   	i|   C                                 L   *           O            y     	`	 `.`PIP|   Ml0|   C                                 L   *           O            y     	`	 `.`PIPt  T                                   L               L                ;         >         >         >            L               L   O      	         L         L      u L   o	   y  &	`  `AH`%//@		` `@`P
9PEPt                C            Y4                             :      y     L    >          L   )      %       L      u 
   4             O     L   o   y     %`"	@	@	` P 	` 	`PJP           L   (L                                        y  `
P$	P   2   k                           	   	               L   L      4            L   O          o   y     	` ` `PIPH   4PH                            :      y >    `"	 	&D   CD                                   O   o    ` `EQ<   h<                                   O    ` P,  ~,                                                 O                           O                     [            L   .         L               u 
          y      	` ` 	` ` 	` ` 	`'
PC	F`@	Pp   ~p   B                          ;         >         >         >    
   
  >    `%////P   +P   $                          ;         >         >    `%//,  hx  c                !              ;         >   >   >            L                     L         L   u         L      L   u               :   	    y 
     (   (  (   (>         L   u 
      ?"      ;      >      	    y    ;      >     >     >    .`%/&K	` `DH	`
P(`

P(	` `"	 	 	

P @H`%*)IT,         b      R              7             `            .W.   X                          :          y       >         >         >         >    `" ////h   h   9   	                          o      ;      >      >   o   >   @`%**:QP   =jP                            ;   L   L        u  ` P#Q  :  '                                          u             gL      L                     u    a         L   ?         ;      L   >     >   u L     u    ;         :         ;      >     >   u L     u    ;	    @` (P ` P ` `%.IPJ
PCH	`EH`.	`%)IPJPCH`%T         &                                               $         p   & Dp   8                         : u     u     y j     k     k   >    `"P 
	-p   _p   8                         : 4     u     y j     k     k   >    `"
P 
	-p   hGVp   8                         : E     u     y j     k     k   >    `"P 
	-p   Qqp   8                         :      u     y j     k     k   >    `"	P 
	-p   p   8                         : b     u     y j     k     k   >    `"	P 
	-p   Rwp   8                         :       u     y j     k     k   >    `"	P 
	-p   p   8                         :      u     y j     k     k   >    `"P 
	-      S                             )     u      L   o   u         3   (O       +`P)`PH` `T         M       P            VH                  $                  g;    >   L      :    y     L   L      u     L   
  u                    L	   L        L
   o   u     L        :      y  >     L      u )        L        u          >   u      L        :      y  >      >   u   (`  ` P(`P)	`+` `PH` 
  P 1P PCJ` 
 	P#T                          O            P                       @b                                         L   L         u           L   L   u 
     L      u          L   L                        `
 ` 
P` PCF`P@; `CV   1|   <                             L   o   u         3   (O       &`PH` `T          ;       9          D  N  c                             g;    >   L      :    y      L      u    	        N      u    t        L   u      L      L	   D               
       u            O         L        u       L   L      u  $         L   L   u           *(`  	`P*`P(`	P(`	 	` (P@`
PCJ
` P &P TD         b     `                                     `            4x   <                          o           3   (O       Y  O       &`J` `/`T          ;       9          t   vt   :                          gL         L       L   ;      >   u  ` 
	P#Q   `   j                            L     u Q        L      7           L   $   
     L   L    Y      `P 3 'Q  j*hx                  &      $   :     y       `   ab~                  M      M   n   L     u     o   
                             o   Q(                       Q              C           :       y        y Q_        	   K           j      k       k   L
      u L      u Q!   !   c:      y        y  &` f +`.`.`P(	`.` 	`@`/	`@` `
  ` `
 PPKM`	 T                            J   _                        )       UZx            	              $              { b      Mw  fL   j           u  f L      
   L   l             z            { b      Mw  fL   j           u  f L         L   l             z   &`  P&`  P"`$	T                               A   .            .     .(  b                              L     L      u 4      L                   )            $   	      L   
               L         L        u 4      L                   )            $         L                  L   L        L   L           L       
*` P `  `.`8H`)P ` ( `.`=H`T         a                    2             _                  	                             >        3(u      L   o   u            3(O   :      y   1   A	+`P)`PH
`	!-`	 T         s                 \  <                                  g;    >   L      :    y                                  &   
         L      u Q     L	      :  
    y  >   u  .,`  ` 	` ` PK`  P#T\                            F  I                                 g;    >    >    >   L      L          
     L       	   	     :    y    l  L       L   :  	    y  >
     >     >      >      >     L            .       l  L       ;      >   u    >   u   ?`  ` +*" ())** & $
PM&P3T         H      F            <(3   S                                  u    s  L   ?vo   u         3   (O       +`P)`PH` `T         M       P            xH                  $                  g;    >   L      :    y   s  L   L      u     L   *  u                    L	   L        L
   o   u   0  L        :      y  >   s  L      u )      s  L        u          >   u    0  L        :      y  >      >   u   (`  ` P(`P)	`+` `PH` 
  P 1P PCJ` 
 	P#T                          O            P                       3                                       s  L   L         u         s  L   L   u 
   s  L      u          L   L                        `
 ` 
P` PCF`P@; `CV   U|   <                           s  L   o   u         3   (O       &`PH` `T          ;       9          D  d  c                             g;    >   L      :    y    s  L      u    	        ?      u            L   u      L    s  L	   D               
       u            O       s  L        u     s  L   L      u  $       s  L   L   u           *(`  	`P*`P(`	P(`	 	` (P@`
PCJ
` P &P TD         b     `                                     `            lx   <                          o           3   (O         O       &`J` `/`T          ;       9          t   [St   :                          gL       0  L     0  L   ;      >   u  ` 
	P#Q   	M   j                          s  L     u Q        L      7           L   $   
     L   L          `P 3 'Q  j*hx                  &      $   :     y       `   ab~                  M      M   n   L     u     o   
                             o   Q(                       Q              C           :       y        y Q_        	   K           j      k       k   L
      u L      u Q!   !   c:      y        y  &` f +`.`.`P(	`.` 	`@`/	`@` `
  ` `
 PPKM`	 T                            J   _                        )       UZx            	              $              { b      Mw  fL   j           u  f L      
   L   l             z            { b      Mw  fL   j           u  f L         L   l             z   &`  P&`  P"`$	T                               A   .            .     .(  b                              L     L      u 4      L                   )            $   	      L   
               L         L        u 4      L                   )            $         L                  L   L        L   L           L       
*` P `  `.`8H`)P ` ( `.`=H`T         a                    2             _                   	                                     3(u    L  L   o   u            3(O   :      y   1   A	+`P)`PH
`	!-`	 T         s                 \  Ka<                                  g;    >   L      :    y                                  &   
         L      u Q   P  L	      :  
    y  >   u  .,`  ` 	` ` PK`  P#T\                             "  ~  	                   $           6  L   u el      L           M                  
   M                   Mw  fL   u  f L                L                5      u  f L                L                     d        o   j     k    y       	
+`P `EJPD `T          o      {                           -     8  n                                           ;     L   >     L   >   y    o            L	     ;
      >   y o                y     	`	%`P$`	I`	
P$`E> `PIP8        w                    g  =         	                       L     u             L               M              $   	         L        L     u         M               L        L     (        L	        L
             ;      >     >   y  .`P-`AH` `AH`&`*#`.`P `.` `/`@	`		P%P          <      -              H             x   p       L   X)&L                                   L     u  ` PP  [,3           
       "      $           gL      L        L   u ek      L        	   M   
    
             M                  Mw  fL   u  f L                L               5      u  f L                L                    d     ~  L	       ;
      >       >       >     >   u   '` `P ` 		PTP  0                                          D       NV  )                                  g;    >    >   L      L      :    y   O        u      L   u            u     L   u      L   o	   y          B      ~  L
      L   :      y   >   u      ;`  `P)`P)`P(`P)`PD` 
 	P(T        #      &                                               L               4      L                         L      O         L   )   	         L      L   y     &` ` ` 	` 
PJP              a9         #   4       >     $                      	  
                                               !  "    g;    >    >    >    >    >    >    >	    >
    >    >    >    >    >   L     L                   L               L                  L               L               L	               L
          j         L                 L       "      "     L       $   $     L       &      &      L     :    y 	  O   y    u     L   u em   /   L        2   M   3    3           5   M   6    6    	     6   Mw  fL   u  f L      <       <   L   =         >    5   >   u  f L      A       A   L   B    	     C      C   d D        o   u 
    L   u ek   K   L        N   M   O    O          Q   M   R    R   "     R   Mw  fL   u  f L      X       X   L   Y        Z    5   Z   u  f L      ]       ]   L   ^   "     _      _   d `          u     4   b   L      c    c      c   c       4   d   L      e    e      e   e   !             g        (   h      h   (       k     7   k   :>    >!   >   >"     #    y r     $   L%     u    v        v   j     k    w         L      ;&     >'      L(     u >)     >*        ;+   ,   >-     >.   o/   >0   ;1     L2   >3   >4   j   9   ;5     !  (>6     >7   u k      h      a   :>6   >8              $   u           >9     #    y u    k     )         :  #    y u    k   J   :  #    y o:   >;   u k     +      r   ;<     >=     >'   u    k      ;>     >?   !  >@   u k     3         :A   >-     #    y u    k   >B   u gLC     LD     L.     LE      LF          u ek      L           M                    M                  Mw  fL   u  f L                L               5      u  f L                L                    d    G      u    H    oI   j      k       k   y   LJ   4      LK                 LJ   4      LL                 LJ   4      LM                  L   u  el      L           M                    M                   Mw  fL   u  f L                L               5      u  f L                L                     d    H    oN   j         k    y ~  LO    P   ;Q     LR   >S      >T   :  #    y           LU        V     >U   W   >X       >Y   Z   1j     L[   4     LK           k      L[   4     LL           k   L\   ]   u A  L^   4     LA           $     ;_   `   >a   b   >c     #    y >d     Le   >e   ~  LO      ;f     >g       >h   "  "  >i     >j     >k     >l   ~  LO      LP   :  >m       >n   	  #    y 
  >S   :	  Ld   #    y       7  b      7  7  >o   >d   u >p   u >p   u  @	`0@@`P(#`P `P( `P `P(` ` `  ` D
	 `P 2 #` #`%)PH N"O`E$*)J,%	@/%	
	P(	 "&&  P,@1PM7	  P-	" J8	PHC	 		P-			P(	 
 P@"ZP@H'`P `P)`EN
JJPDO` ` ` /`P `EUOSPDV` %%	.	*	" @_*-+  UDh *@m	-	 +%%)--))) +*")- )"  $@w3PHn/PHV(PC  T  @                             u                                            	           
                      &     @   yoU@                             	   	     u  
`P  Q9             	              $        j     Mw  fL          u  f L         L   l
    ;            >   lz      &` 	%@#PF	`$T                                  /   .   l   #Wi\                           gL      L     L     L             L   gL     L        L	   L
       L        3   (y   L        3   (y   L        3   (y   L        3   (y  :.B` "` ` ; P$` < P$` 8 P$` 9 P%Pl     1         ?   R                                B             4            y                ` 	`@P   @8   B                                2                L      u L   y     ` 	`PP)P  x                 7                 g;    >   L      :    y    `    G     u        L   M   ~  L       ;	     L
   >   :   >     L   >     L   >     1A;      >      >      >      >     L   M>   ;      >      >      >      >     L   M>     L       '   !      '   '   >"   >#    ~  L       :  $    y  >   :  L#   $    y %   >&   >#   u >'   u   ,`  `P(` `@%%	.	"*..'%***/%***/ 8@	 +%" ("@'O/PH!P3.T                       0   xFnP0                                 `Q\   #N\   -   	                          ;      >      >   o   >   	`%**J  %C                  R      $                   	  
          gL     L     L       L   4      L                                     L             	      	      L   
          u ek      L	           M          	          M          
        Mw  fL
   u  f L                L      	         5      u  f L                L       
     !      !   d "   ;      >      >      >   
  
  M    L   4   )   L      *    *      *   *     -(    L   4   .   L      /    /      /   /     -(             	  	     Q   3        4        4     3   (5        3   (  <  7   	     _   9        :        :     3   (;        L   L     (3   (     ?   	     Q   A     3   (        D        D     3   (E     n   E   	     Z   G     L   L     (3   (        L        L     3   (M     M   ;   ;       >     >   >!     2` ` `)` ` '`P `

 `  -`  -`*`*	` ` & `  ` ` & `  ` `  ` & ` `  ` &@`		.T                                           	       PJ)P                        $       L      u Mw  fL   u  f L                L   	         
    5   
   u  f L                L                                 d    j      k      k    *$`
P  `	T  p               	               b                              3  `<   -    `  @x  y    `  `  `  -    `  -    `x  y    `y  *  +  	  `   y  x  
  `  `  `x  {             5  6    `  `  `  `     P  p  `          `-    `  `  E    p<     `  `    P  p  `        D     `
  @          `  `x  y  +  *    @          `  `5  6  y  x  +  *            @  @  @  @  @  {     `  `%    W  X  Y  Z  ]  %  ^  _    @5  6  x  y    @  `     `8     @g  a  0    @h  e  f  D     @  @!  `"  `  @x  y  Z  0  h  W  m  n  o  p  q  6  r  H  5  v    @w  x  y  u     @+  *  {  }    @  @    @K  z    @        $  `%  `x  y  %  0  Z  h  a    @u   H     @!  @              5  6  {  w      "  @  D   e  f  #  `  @  8  k    p *  `-  `%    .  `  /  `  1  `2  `%  y  4  `5  `3  `%    ]  $  p  %  p6  `'  `(  `%  a  0  g  Z  h  %  @          C      C       &  @^  6    A  j         )  `'  @    p+  `   ,  `2    p(  @)  @e  *  @f  ]     p  !  p0  `"  pE  #  p&  p+  @,  @-  @&  `#  @$  @  8  k    p 7  `.  @  *    +      9  `8  `  )  p;  `<  `0  1  @W    C     =  `D   5  q  2  @3  @  e  >  `r  6  4  @5  @  6  @:  `/  @0  @  8  k  +  p ?  `@  `%  Z  h  ^  6  y     8  @    3  9  @{   :  @x  ;  @B  `C  `x  y  %  a  c      =  @>  @D   e  A  `<  @c  8  k  .  p G  `H  `x  y  C  @E  `F  `x  y  %  A  @      B  @1  p C   D  @I  `        J  `D   E  @  e  D  `?  @@  @  8  k  0  p L  `M  `x  y  %  0  a  c      H  @I  @D   N  `*  +  5  6  O  `   K  `F  @G  @k  3  p S  `Q  `R  `%  0  Z  h  L  @   6  pC   y  6  +  *      ^    {       a      x  T  `D         M  @N  @f  O  @P  `J  @K  @  8  k  5  p U  `  V  `  w       W  `      X  `        Y  `  Z  `  [  `  \  `  ]  `^  `j       P     _  `   a  ` b  ``  `  B  pe  `  f  `% w      g  `& w      c  `d  `  D  p" # $   ]  E  pF  ph  `i  `j  `+ , -   k  `   l  `1 m  `W  @3 4 X  @5 6 n  `o  `/ 7 8 9 p  `q  `  0 r  `s  `  0 t  `<   C u  `D !     A v  `w  `n  +  *  G H Y  @$  x  `x  y  `z  `L +  *  $  )     Z  @x  y  {  `|  `C [  @O x  P y  }  `~  `  `L   x    y  +  *    `  `] n  ^ _ ` \  @  `  `3     `  `L   3   4 ]  @x  y    `  `h  K  z  W  f 6  ^  @3 4 0   `x  ] y  _ _  @+  *    `$     k   `  `  0 m   n   3 4 \   1  `  @+  *  x  y    `  `C       `+  *  f O P   `  0 1 v w n  x y (  { a  @x  y    `  `f   _   ]   x    y  c  @+  *    `  `p      `d  @x  y  +  *    `  ` f   `0   `  `  `   ]  `  p f   `     a  p    `  `          `  `u   m  o  W  n   <   A  j       c  pe  @    +      *  x  y    `  `+  *  f  @  `x    `  `f  pf g  @3 4 0   `x  ] y  _     h  @+  *    `     `  ` f z    0   `  `  `  `  `{    6  i  @5  W  j  @x  y  +  *    `\   1    `x  y  +  *    `    `  `  `  q  pL   `  `p  pL     +  *       a l  @   D        `   `  `n  po  p  `  `   ` d n  @    `   `  `  A  j          u  p  ` d    `   x  p    `  `v  pm  @       A  j        s  pt  p w  p  `  `K  Z  D      `  `  `  `  $     !     o  @ *     `    `  `         `  `(      `   `  `   p  `   `   `  `  `D     
   p  `  ` t  @%  W  Y  Z      p  `D      `    p  `   `   p  `   `u  @5  6      `v  @5  6    `  `w  @     6  x  y  D       x  @% y  @  `D     h     `  `p  @%    W  X  Y  Z  h  q  @5  6      r  @x  y  s  @a     A  j        p  p   p  p  p  p   p  p  p  p  `z  @ *      `  `u   H   |  @ }  @~  @  @  `  p{  @  8  k    p   `D   k    `D   k    `D   k    `D   k    `D   k    `D   k    `D   k    `, F   3 4 ' )   `  `  @) C   , -      `' E    p5 D    4 6   `  `&   p8 7   `  `  @) C   4   `'   >    6 , F   3   `  `&   p? 7   `) 5 >   @  `  `  pD 7 E   `4     E  ` `A  j       `  `D     ` `  P    p  O ]  %  P     ` `!     '     S  `	 `  @c C     N     f 5 D     ` `a &   p7 D   
 ` `  @) +  *  C   5 ] D    l k   m c n   @p o  `, F   3 4 ' )  ` `  @) C   , -     `' E    p5 D    4 6  ` `&   p8 7  ` `  @) C   4  `'   >    6 , F   3  ` `&   p? 7  `) 5 >   @ ` `  pD 7 E  `4     E  `  `A  j      ` `D    ` `  P    p  O ]  %  P    ! `" `!     '     S % `& `  @c C     N     f 5 D    # `$ `a &   p7 D   + `, `$      - `  G H   @+  *  . ` ) `* `  @G +  H *     p   @    p' `( `   A  j         p/ `0 ` )    A  j     5   @   3 `4 `  1 `2 `  @  C         p5 W D    7 `8 `9 `A  j       @  : `h  0      ; `5  +  *  6      a    < `= `  1  5 `6 `  @                     C      A  j         p+  *  -  w         D   $     @H  ]  m  r    @f W  %    p   @ 5  h    @  3        p     @u     @    Y     a        p  x  y      p5 W   @          P        @          @         ) > `? `@ `  @ C    5 \   @  X           @w             @          D     ) A `C `D `%  0  a          A  j       @       {   x  y  w     a   6  *      +    @  @e  B `  @ 8  k    p E `F `  -  A  j          `       @  @    p(            p  @  @  p  p  p  p  p  pL    @	  p
  p  p  p  p  @  @  @	  @  p  p  p  p  p  p  p  p  p  p  p'  p(  p*  p7  @,  p-  p/  p2  p4  p7  p8  p9  p:  p;  p<  p=  p>  pP  @?  pQ  @@  pR  @A  pS  @T  @U  @C  pG  pH  pV  @I  pJ  pK  pL  pM  pN  pO  pP  pQ  pR  pS  pT  pU  pV  pW  pX  pY  pZ  p[  pb  @\  p]  p^  p_  pb  pd  pe  pg  ph  pi  pj  pk  pk  @  y  v  {  _  k   }  w  ^  l  pm  pr  py  p    z  p {  p|  p}  p~  p  p  p  p  p  p  p  p  p  p	    p9   pN  A   pF   p  p  p  @  p  @i &   p7   p  p  p  p  p  p  @  p  @  p      A  j       p   p   p   @  p  p  p  pX                            !             !
       !              "        	      $              &              '              )              -              .              /        &      8        )      :        (           ! -      @        4      B        2           ! ;      7        :           ! ?      G        E      I        K      J        V      L        i   "   U      !
    (   i                     !
             "  '                7        "             !            !             !             !            !            !            !            !            ! /             8             7          ! R             ;          "  Z              y     c        l          "                         "            !
                        "                 "        "              !
                                             y                          w                                     	                                            !                       !           !           ! (     '       *     !       /     *       1            3     2       :     )       @     :       D     ;       K     B       P  	   E       Y     J       [     }        f     N       n     Q       o     L            a         
   c                         k            l            p            }         
   ~                                         !           !      v                  !                                      1            4            ;     {        >     _       
 K     ^        N            r            S            ]            W            V          !             y          !           !           ! v                      !           !           !
                                                                       !   (                    !           !   
        !           !           !           !            !           !            !           !      !     !      "     !      #     !           ! J          !
 ;            @  
        "  R          !
 U          !
 X          !
 [          !
 ^          !
 a          !
 d          !
      !       n     &     ! g     '     !      $            (     !      B            C     !
      /            =            *     !      ;            +     !      ,     !      -     !      v            .     !      /     !      w            0     ! &     }       !     C     !
 ,     x       6     {       1     2     ! D     z       X     3     ! L     4     ! }  	          o     5     ! _     6     ! m     7     !           !
      8     !      9     !   q   :     !      ;     !           !
             !
      >     !      >     ! 6  (          ^                      !
 _  "        "              H      I     I                 g    g                   0  K  0  K  "                 5    5  0               G    6    3                       6                       9               8  e     e  <               |    f    ?                 L    L  C               f    M    F                 	    	  I               
  
  	  
  V                 m  
  m  Z   '            ;  i  ;  i  [   *              G    G  a               j    H    n   #            5  U  5  U  r                 R    R  y               /  N  /  N  z   6            o    S    |                                        k    k                   4    4     $          C Q  l  K  l               C   #'  n  #'  +             0'  0  0'  0  c            C f'  0  ^'  0  f             0  )C  0  )C              G X1  "C  P1  "C                9  9  9  9                ;  H<  ;  H<                =  =  =  =    L            =  =  =  =    m            >  @  >  @    Q            @  A  @  A                @  @  @  @    >            @  A  @  A    c            A  .A  A  .A                BC  D  +C  D               "D  dD  D  dD                CD  `D  CD  `D               xD  CI  pD  CI              C D  <I  D  <I               C I  M  I  M  K  $           M  P  M  P  p            C aN  P  YN  P  w              Q  X  P  X              G uQ  X  mQ  X                IR  R  IR  R               X  a  X  a                9Y  a  7Y  a               b  l  	b  l              G b  l  }b  l                Uc  fc  Uc  fc  '               Qm  m  ?m  m  g               m  m  m  m  j              n  n  m  n  p              n  no  n  no  t              ~o  o  oo  o  x              p  p   p  p  ~              p  ?q  p  ?q                Uq  r  @q  r                vr  hs  \r  hs                s  t  s  t               Lt  t  9t  t                xt  t  xt  t    !            u  7x  u  7x                v  v  v  v    #            w  w  w  w    9           x  3x  x  3x               Sx  y  8x  y                y  5z  y  5z                 z  z  z  z                
{  N{  z  N{                e{  ?|  O{  ?|                V|  }  @|  }                 ~  8  }  8    $            V  b  9  b                {    c                  -  M    M                 d    N                                                .                      8                 *    *  A              G    +    u              .  1    1  |              p    2      ?              +    +                D    ,                                                  $                      +                      "                      %                      @                    #                     ,              i    i    6  1              I    I  E              p    J    O  '              B    B  Y  %             6  ~    ~  u                      x              '                    C           %                                    >    >               S    ?                    4    4                G    7                                        {    {      "                                                            8    8    )                    #  0             ^  H  L  H  4               ^    ^    =  
               ;    ;  ?                      R              )  /    /  g                 o  m  o  j                $  p  $                8    %                                                 	             )                      W    W      *              {    {    )            f  (  f  (    $               "    "    N                                   r  >  r  >    	               2    2                }    }      	                                      1    1    	                                    N    N      "                        (             e    e    :                u    u  B                Z  
  Z  C                n    n  I                      a                '    '  e              ;    ;    i                      m                5    5  q              C    C    u                      y                                    0    0      $            a  z  a  z    -            &                      Z  _  Z  _    '                                                        J    6                    s    s              @ c    c      #              H t  H                                 D  D   #            I  I  	                  "              	  	  $  $            >
 W >
 W *  -                :              < C < C ;  '                K               p  p L              6  !  T               a  a W            @ Q  Q  _  #            y 7 b 7 o                                
 8 
 8   #            C  C               ^ $ ^ $                      1                               |  j! |  j!               ! z$ ! z$               #  $ #  $                G% ; G% ;               ' ' ' '   8          @ &, , &, , 	              . 1 . 1  	              2 2 2 2 0	               3 S4 3 S4 9	               < B < B z	  :            C @C 
C @C 	             WC H WC H 	              C H C H 	              H I H I 	  &          m                                 
                                                                      	                                                                                          	                       	  	                                                                                                                                                 	           	           	           	          i 	             Y                                        !   "   #   $   %   &   (   +   ,   /   4   5   6   7   8   9   :   ;   =   ?   A   E   F   G   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z   [   ]   ^   _   `   a   b   c   d   e   f   h   t   u   v   |   }   ~                                                          5 9ZD/K      i]di]PIk>   q    O^partitionKey=%28http%2Clocalhost%29,:http://localhost:5173/node_modules/.vite/deps/chunk-JPVZI2IN.js?v=e7284969 strongly-framed 1 request-method GET response-head HTTP/1.1 200 OK
Vary: Origin
Content-Type: text/javascript
Cache-Control: max-age=31536000,immutable
Etag: W/"149ef-G8y0RjyFZEgzVsT4O2f9azt/VmE"
Date: Wed, 07 Jan 2026 02:21:13 GMT
Content-Length: 84463
 original-response-headers Vary: Origin
Content-Type: text/javascript
Cache-Control: max-age=31536000,immutable
Etag: W/"149ef-G8y0RjyFZEgzVsT4O2f9azt/VmE"
Date: Wed, 07 Jan 2026 02:21:13 GMT
Connection: keep-alive
Keep-Alive: timeout=5
Content-Length: 84463
 ctid 2 net-response-time-onstart 12 net-response-time-onstop 12 alt-data 1;84463,javascript/moz-module-bytecode-20251217233610-8l alt-data-from-child 1  Q